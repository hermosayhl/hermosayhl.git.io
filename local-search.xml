<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>排序(14) 外部排序</title>
    <link href="/2019/12/14/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(14)%20%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/12/14/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(14)%20%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>文件，磁盘</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
      <tag>B树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(11) sort 源码剖析</title>
    <link href="/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(11)%20sort%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(11)%20sort%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>sort 源码当然是分两个了，一个是 C 语言的 qsort，一个是 C++ 的 std::sort，二者面向工业，性能自然比我写的高一筹。看看源码也是不错的，能学到很多东西以及技巧，当然， C++ 的 std::sort 可能涉及到很多的模板和函数式，可读性更没那么高。</p><h1 id="性能表现"><a href="#性能表现" class="headerlink" title="性能表现"></a>性能表现</h1><p>先来瞅一波性能表现：</p><h1 id="qsort-分析"><a href="#qsort-分析" class="headerlink" title="qsort 分析"></a>qsort 分析</h1><pre><code class="C"></code></pre><h1 id="std-sort-分析"><a href="#std-sort-分析" class="headerlink" title="std::sort 分析"></a>std::sort 分析</h1><p>内省排序 intro sort</p><h1 id="boost-sort-分析"><a href="#boost-sort-分析" class="headerlink" title="boost::sort 分析"></a>boost::sort 分析</h1><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
      <tag>测评</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(13) 数据结构之下的排序</title>
    <link href="/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(13)%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(13)%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%8B%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="基于树结构的排序"><a href="#基于树结构的排序" class="headerlink" title="基于树结构的排序"></a>基于树结构的排序</h1><p>线段树<br>平衡树系列：AVL、treap、split_tree</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(9) 基数排序</title>
    <link href="/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(9)%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(9)%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>当初学习基数排序，是因为它宣称有 O(N) 级别的排序性能，乍一看，好神奇，还能这样排序？如今回顾，才明白它满足某些条件时，的确具有近似 O(N) 的性能，而且基数排序完全可以理解为桶排序的改进版——之前说过，桶排序有个很大的缺点，那就是存在大量的空间浪费，如下图：</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/23-24-41.jpg" srcset="/img/loading.gif" alt><br>仅仅是两个元素而已，但桶排序占据的空间却达到了 $10^{8}$，即使是按每 100、10000 分布到若干个桶中，空间浪费依旧很多。基数排序可以看作是从此出发的，将一个数组分解为多位，根据多位的相对比较，能将上图的空间降到 8 甚至更低！同时具有桶排序 O(1) 定位的优点。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一些无需数字，对它们排序，默认从小到大</p><h2 id="基数排序的过程"><a href="#基数排序的过程" class="headerlink" title="基数排序的过程"></a>基数排序的过程</h2><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/849589-20171015232453668-1397662527.gif" srcset="/img/loading.gif" alt><br>基本原理，就和上图一样简单：</p><blockquote><ul><li>位数多的数字一定更大，例如 340 &gt; 99</li><li>同样的位数，越靠前的位越大，数字也越大，例如 340 &gt; 309</li></ul></blockquote><p>但这里涉及到一个概念</p><h2 id="基数到底是什么？"><a href="#基数到底是什么？" class="headerlink" title="基数到底是什么？"></a>基数到底是什么？</h2><p>一般默认基数 = 10，因为很好理解，10进制，将数字拆分成每一位嘛，所以每一位的取值范围是 0-9，需要 10 个桶。<br>但是当基数 = 100，就是 100 进制，数字按照每两位拆分：<br>如下，每次按 100 取出 ，放入桶中<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/15-39-47.jpg" srcset="/img/loading.gif" alt><br>收集一波，序列是 1300，658，699，后两位是从小到大有序的；<br>继续按 100 取，<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/15-41-35.jpg" srcset="/img/loading.gif" alt><br>收集一波，序列是 658，699，1300，前两位也是从小到大有序的，其中 658 因为第一次收集保证了一定在 699 前面，所以它们放在同一个桶中并不影响它们最后的顺序。<br>同理当基数 = 1024，数字就按照 1024 划分：<br>先按照 1024 对 1024 以内的部分排序<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/15-54-02.jpg" srcset="/img/loading.gif" alt><br>收集一波，序列是 1045，79，999，此时三个数在 1024 以内的部分已经有序<br>再对 1024 * 1024 以内的部分排序：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/15-59-03.jpg" srcset="/img/loading.gif" alt></p><p>…<br>…<br>…</p><p>归纳一下基数排序的过程（以基数=10为例，方便理解）：<br>从低位开始，</p><blockquote><ul><li>取出每个数字的当前位值（个十百千），依旧桶排序的程序摆放好</li><li>从 0-9 的桶中收集</li></ul></blockquote><p>为什么从低位开始？例如 340 和 9，位数不匹配，9 并不存在十位数和百位数，但 340 和 9 都具有个位数，要同一位才能进行比较 0 &lt; 9，但是 340 胜在位数。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码实现还是有一些技巧的：</p><ol><li>对数组元素进行“规范化”，因为位数要放到下标为整数的桶中(例如 0-9 )，所以基数排序处理的是整数！负数需要将数组元素值进行区间的平移；小数需要将小数规范为整数；字符串需要哈希或表示成可比较的正整数……重要的是最后要把原数组元素还原回来。以下代码只是处理了负数的情况。</li><li>每个桶中会放多少个元素，无人知道，是不确定的，如果直接声明数组，空间浪费较大；动态生成数组，缺少申请的数组大小……为了方便（懒惰），我使用了 std::vector。<pre><code class="C++">// 基数排序void radix_sort(int *const arr, const int left, const int right) { const int L = right - left + 1; // 对数组元素进行一定的校正，例如偏移到以 0 开始的整数区间 const int min_value = regulation(arr, L); // 初始化 radix 数组，做预处理，后期不必再用 pow 求 init_radix_arr();        // 总共要进行 max_radix_len 次收集，最多次 max_radix_len 次 const int max_len = get_max_len(arr, L); int i, t, pos, cnt, j; for (t = 0;t &lt; max_len; ++t) {     // 根据第 t 位数摆放到 0 - (radix - 1) 桶中     std::vector&lt;int&gt; buckets[radix];     for (i = 0;i &lt; L; ++i) {         pos = get_bucket_pos(arr[i], t);         buckets[pos].emplace_back(arr[i]);     }     // 收集一波     cnt = -1;     for (i = 0;i &lt; radix; ++i) {         const int _len = buckets[i].size();         for (j = 0;j &lt; _len; ++j)             arr[++cnt] = buckets[i][j];     } } // 将数组元素偏移回来 for (i = 0;i &lt; L; ++i) arr[i] += min_value;}</code></pre></li></ol><h2 id="更新-12-15"><a href="#更新-12-15" class="headerlink" title="更新 12.15"></a>更新 12.15</h2><p>为了代码的统一性，还是强制自己写了一回 C 语言的基数排序。原理一致，只不过利用 _count 统计了每个桶放了多少个数字，从而扫描每个数字，看这个数字放在哪个桶的第几个数上，然后放在对应的位置上即可。</p><pre><code class="C">// C 版基数排序void radix_sort(int *const arr, const int left, const int right) {    const int L = right - left + 1;    // 对数组元素进行一定的校正，例如偏移到以 0 开始的整数区间    const int min_value = regulation(arr, L);    // 初始化 radix 数组，做预处理，后期不必再用 pow 求    init_radix();           // 初始化一些辅助数组    int *_count = (int *)malloc(sizeof(int) * (radix + 1));    int *pos = (int *)malloc(sizeof(int) * L);    int *sub = (int *)malloc(sizeof(int) * L);    int i, t;    // 总共要进行 max_radix_len 次收集，最多次 max_radix_len 次    const int max_len = get_max_len(arr, L);    for (t = 0;t &lt; max_len; ++t) {        memset(_count, 0, sizeof(int) * (radix + 1));        for (i = 0;i &lt; L; ++i) {            sub[i] = arr[i];            pos[i] = get_bucket_pos(sub[i], t); // 放在哪个桶            ++_count[pos[i] + 1];  // 这个桶的下一个桶的位置后挪一位, 在后面体现        }        for (i = 1;i &lt;= radix; ++i) // 计算每一个桶的开始位置            _count[i] += _count[i - 1];        for (i = 0;i &lt; L; ++i) {            const int index = _count[pos[i]]++; // 这个放在 pos[i] 的数字, 该放在哪里            arr[index] = sub[i];        }    }    // 这样的写法....可惜不能用 RAII; 日后用内存池替换    free(sub);    free(pos);    free(_count);    // 将数组元素偏移回来    for (i = 0;i &lt; L; ++i) arr[i] += min_value;}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>假设数据规模 N<br>假设数据最大值为  Q，基数为 R，那么总共要收集 $K = \log_{R}{Q}$ 次；<br>每一次收集比较，都要取出每个数的当前位的值O(1)，放到桶中O(1)，共 N 个数，累计 2 * N 次操作，收集遍历的长度恰好是 N，累计 3 * N 次操作。<br>所以，时间复杂度是 $O(N * K)$。<br>其中 $K = \log_{R}{Q}$,是对数得到的，一般都很小，大部分情况都满足 N &gt;&gt; K，即时间复杂度逼近 O(N)。</p><blockquote><p>基数为 10 最好理解了。假设最大值 Q = 100000000，基数 R = 10，那么要收集 K = $log_{10}{100000000} = 8$ 次，代表有 8 位</p></blockquote><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>就地排序，这部分不计算。<br>若干变量，i,j,cnt等，O(1)。<br>K 次收集，每次收集都要创建桶，桶的容量理论上是 N，但每次都可以回收桶内存，所以空间复杂度是 O(N + K)。</p><h1 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h1><p>每次放入桶中，两个相同的数字都是按照读取的顺序放入的；每次收集（取出），处于同一桶内的两个相同数字，也是按照读取的顺序取出的，不存在顺序改变的情况，因此基数排序是稳定排序。</p><h1 id="分析与优化"><a href="#分析与优化" class="headerlink" title="分析与优化"></a>分析与优化</h1><h2 id="1-基数如何选取？"><a href="#1-基数如何选取？" class="headerlink" title="1. 基数如何选取？"></a>1. 基数如何选取？</h2><p>基数到底是什么？大家默认的基数就是 10，因为生活中都是以 10 进制表示数字的，但是 10 一定是最好的吗？<br>从应用场景来看</p><blockquote><p>基数排序的一个经典例子就是给扑克牌排序——扑克配由两个基数组成：花色(桃&lt;心&lt;梅&lt;方) + 面值，对于花色来说，并不存在数字形式的基数，但可以视作(1&lt;2&lt;3&lt;4)；对于面值来说，基数是 13，而不是10。两个基数可以选择优先级，先按花色排序还是先按照面值排序。由此可以看出，基数不是固定的，而是可以根据应用灵活多变的，照样可以很快地排序。</p></blockquote><p>从运行效率来看</p><blockquote><p>一般的基数排序都会默认 10，但是根据时间复杂度 $O(N\log_{R}{Q})$ 可以看出，基数排序的效率取决于三个数 N、R、Q，其中N 和 Q 是固定的，R 是自行设计的，所以 R 越小，理论上时间复杂度就相对更低。<br>假设最大值达到了 $10^{8}$ 级别</p><ul><li>基数 R = 10，共需要收集 8 次</li><li>基数 R = 100，共需要收集 4 次</li><li>基数 R = 10000，共需要收集 2 次<br>……<br>差别很明显，但是相应地空间复杂度也升上去了，例如基数100就需要 100 个桶，基数 10000 就需要 10000 个桶。</li></ul><p>一般而言，100 或 1000 就足够了。为了利用位运算的优势，甚至有基数为 1024 的情况。</p></blockquote><h2 id="2-存在的问题？"><a href="#2-存在的问题？" class="headerlink" title="2. 存在的问题？"></a>2. 存在的问题？</h2><p>由上可见，基数排序适合那些可以分解为多个基数的数据排序，对于字符串、结构体等可能需要另外的方式。<br>其他方面，都接近 O(N) 了，我还能要求什么呢，哈哈！</p><h2 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. 性能优化</h2><p>原理上很难再做出优化了，但自己写了基数排序后，再上网看看其他人怎么写的基数排序，才明白“原理大家都对，但是现实中的性能表现就是不如别人”。<br>这位博主的文章<a href="https://blog.csdn.net/yutianzuijin/article/details/22876017" target="_blank" rel="noopener">基数排序的性能优化</a>写的很好，为了优化性能简直是“无所不用其极”，介绍了很多小 trick，对我有不少启发——为此，该博主还做了对比实验一一验证了他提出的小 trick，其在细节和性能表现上的追求精神更是值得我们学习。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>为了简便，直接使用了 C++ 的容器 std::vector，并且没有正式 C 调用 C++，而是借助 C++ 的强大兼容性……<br>不用 std::vector 也可以写，但是代码没有那么好理解了。<br>当然，借鉴了那位博主提出的一些 trick。</p><pre><code class="C">#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;stdbool.h&gt;#include &lt;vector&gt;int *get_array(const int L);void free_array(int *arr);void display_array(int *arr, const int L);// 基数排序相关static const int radix = 10; // 基数const int radix_size = ceil(log(INT_MAX) / log(radix)); // 按照基数划分需要收集多少趟static double radix_arr[radix_size]; // 预先计算好每一位的最低值并存储void radix_sort(int *const arr, const int left, const int right);int regulation(int *const arr, const int L);void init_radix_arr(); int get_bucket_pos(const int value, const int level);int get_max_len(const int *const arr, const int L);int main() {    const int L = 12;    int *arr = get_array(L);    radix_sort(arr, 0, L - 1);    display_array(arr, L);    free_array(arr);    return 0;}// C++ 版基数排序void radix_sort(int *const arr, const int left, const int right) {    const int L = right - left + 1;    // 对数组元素进行一定的校正，例如偏移到以 0 开始的整数区间    const int min_value = regulation(arr, L);    // 初始化 radix 数组，做预处理，后期不必再用 pow 求    init_radix_arr();           // 总共要进行 max_radix_len 次收集，最多次 max_radix_len 次    const int max_len = get_max_len(arr, L);    int i, t, pos, cnt, j;    for (t = 0;t &lt; max_len; ++t) {        // 根据第 t 位数摆放到 0 - (radix - 1) 桶中        std::vector&lt;int&gt; buckets[radix];        for (i = 0;i &lt; L; ++i) {            pos = get_bucket_pos(arr[i], t);            buckets[pos].emplace_back(arr[i]);        }        // 收集一波        cnt = -1;        for (i = 0;i &lt; radix; ++i) {            const int _len = buckets[i].size();            for (j = 0;j &lt; _len; ++j)                arr[++cnt] = buckets[i][j];        }    }    // 将数组元素偏移回来    for (i = 0;i &lt; L; ++i) arr[i] += min_value;}// 将数组偏移到以 0 开始，其他数据类型可以另外设计，例如 float 乘以某个大值，字符串哈希成某个值等等int regulation(int *const arr, const int L) {    int min_value = INT_MAX, i;    for (i = 0;i &lt; L; ++i)        if(arr[i] &lt; min_value)            min_value = arr[i];    for (i = 0;i &lt; L; ++i)        arr[i] -= min_value;    return min_value;}// 预处理小 trick，空间换时间void init_radix_arr() {    int i;    for (i = 0;i &lt; radix_size; ++i)         radix_arr[i] = 1.0 / pow(radix, i);}// 获取 value 第 t 位的值// inlineint get_bucket_pos(const int value, const int t) {    return int(value * radix_arr[t]) % radix;}// 获取最多需要收集多少次，基数 = 10 时就是最大值有多少位int get_max_len(const int *const arr, const int L) {    int max_value = arr[0], i;    for (i = 1;i &lt; L; ++i)        if(arr[i] &gt; max_value)            max_value = arr[i];    return ceil(log(max_value) / log(radix));}// 输入一个数组, 返回数组首地址int *get_array(const int L) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    for (i = 0; i &lt; L; ++i)        scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free\n&quot;);    }}// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(8) 快速排序</title>
    <link href="/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(8)%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(8)%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>真是不想回顾快速排序，因为当初学习它的时候，由于递归学的很差，快排也不是很好理解（思路与众不同），所以一直把它当作最难的排序。但是，我相信，几年之后的我，一定能学懂它！<br>快排在排序算法中却是最著名的，甚至是全世界应用最多的算法之一，它的发明者<a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">Charles Antony Richard Hoare</a><br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/19-02-18.jpg" srcset="/img/loading.gif" alt><br>更是获得了图灵奖，名列计算机科学名人堂，他对于计算机与程序语言的发展都做出了卓越贡献(quick_sort、case语句就是他提出的)。上网查查大佬的生平，对我等菜鸟对于科学研究亦是一种激励。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一些无需数字，对它们排序，默认从小到大</p><h2 id="快速排序的过程"><a href="#快速排序的过程" class="headerlink" title="快速排序的过程"></a>快速排序的过程</h2><p>快速排序基于以下设定，每次设定一个基准元素（紫色块），将比它小的数都放在左边，比它大的数都放在右边，例如下图：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-22-35.jpg" srcset="/img/loading.gif" alt><br>这样做有什么好处呢？<br>如下，以 4 为基准数<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-26-25.jpg" srcset="/img/loading.gif" alt><br>可以发现，左边区间的数字都一定比右边区间的数字更小！<br>这样一来，每个单独区间的排序只需要考虑自身就够了。<br>如上例，划分为：</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-29-51.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-29-58.jpg" srcset="/img/loading.gif" alt><br>然后问题逐渐划分为可解的子问题，如下:<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-22-43.jpg" srcset="/img/loading.gif" alt><br>最终结果就是已排好序的数组。<br>好了，快速排序结束了！很简单！<br>到此可以自己尝试写代码了。其中细节就是如何最快根据基准元素划分的问题，经典的有“挖坑法”和“指针交换”、“前后指针”等方法。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="1-划分为子问题"><a href="#1-划分为子问题" class="headerlink" title="1. 划分为子问题"></a>1. 划分为子问题</h2><blockquote><p>这里是快速排序的精髓所在（为什么？因为如何划分很简单，重要的是能想到通过“划分”的手段减少排序所需的计算量！网上不少资料和代码都将重点放在了如何划分上，什么“占坑”、“指针交换”等等如何划分上去了，个人认为有些“喧宾夺主”的意味，如何划分在快速排序的思想上根本就没有提到，它只不过是其中一个细节实现而已，当初我就是一直纠结于这个实现上，调各种临界条件、考虑各种特殊情况……最终就是，我对快排的印象就只留下了“它的临界条件不好写”、“我老是写不对”，后悔）。</p></blockquote><p>我的脑海中有这么一张图：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-22-43.jpg" srcset="/img/loading.gif" alt><br>很简单嘛，每次找一个交汇点的位置，然后将数组划分为左右两部分，左右两部分递归该过程。<br>临界条件：只要区间存在，就需要划分为子问题。</p><pre><code class="C">void quick_sort(int *arr, const int left, const int right) {    if (left &lt; right) {        int base = patition(arr, left, right); // 找一个交汇点        quick_sort(arr, left, base - 1); // 对左边划分        quick_sort(arr, base + 1, right);// 对右边划分    }}</code></pre><p>全程，快速排序到底在哪里进行“排序”操作的？<br>划分！<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-22-35.jpg" srcset="/img/loading.gif" alt><br>如图，每次快速排序都能找出一个基准值，将它放在它“应该在”的位置，这就是一个排序的操作，排序结果不就是每个数字按照从小到大摆放在它应该在的位置的么？快速排序在不断划分的过程，就是不断确认每一个元素应该在的位置。</p><blockquote><p>根据“递归皆可迭代”，对于亿万数据来说，递归是有可能爆栈的，而且非递归没有创建堆栈和函数调用的开销。</p></blockquote><p>所以，基本框架不变，只需要自己保存区间信息即可：</p><pre><code class="C">// 非递归版void quick_sort_plus(int *arr, int left, int right) {    int *_stack = (int *)malloc(sizeof(int) * (right - left + 1) * 2);    int cnt = -1, base;    _stack[++cnt] = left;    _stack[++cnt] = right;    while(cnt &gt;= 1) { // 还存在区间未处理        right = _stack[cnt--]; // 注意这两句的顺序        left = _stack[cnt--];        if(left &lt; right) {            base = patition(arr, left, right);            if(base + 1 &lt; right) {                _stack[++cnt] = base + 1;                _stack[++cnt] = right;            }            if(left &lt; base - 1) {                _stack[++cnt] = left;                _stack[++cnt] = base - 1;            }        }    }    free(_stack);}</code></pre><p>注意点如下：</p><blockquote><ol><li>_stack 为什么要 new ? 如果直接声明数组，例如 int _stack[N],是存储在栈上的，这样的写法并不能完全解决“爆栈”的问题，因为要保存的堆栈信息是一样多的（为什么一样？因为要排序的区间和递归版的一模一样），只是减少了函数调用的开销而已。</li><li>_stack 数组为什么大小是数组元素个数 = (right - left + 1) * 2？因为最差的情况下，每次划分的基准元素都是最值，这样一来，递归深度 = 数组元素个数，每次存储两个元素（区间）。这样做是考虑了最差的情况，存在一定的空间浪费，如果可以的话，我当然直接 std::vector 和 std::list 了，但为了强制自己写 C 语言，emm。</li><li>注意 cnt 代表的是栈顶下标，每次取出两个元素，所以终止条件是 cnt &gt;= 1 说明 _stack 中至少还有两个元素。</li><li>注意 right 和 left 取出的顺序，因为栈的特性，后进先出，所以区间要对应好。至于左右区间的先后问题，先后并不影响结果——因为基准元素保证了左区间所有元素都小于右区间所有元素，二者之间不存在逆序对。</li></ol></blockquote><h2 id="2-如何划分："><a href="#2-如何划分：" class="headerlink" title="2. 如何划分："></a>2. 如何划分：</h2><p>我比较熟悉的就是指针交换法了，根据 4 划分<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-32-03.jpg" srcset="/img/loading.gif" alt><br>不断比较，</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-36-44.jpg" srcset="/img/loading.gif" alt><br>发现，2 比 4 更小，6 比 4 更大，因此第一次交换，<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-36-16.jpg" srcset="/img/loading.gif" alt><br>直到左右两个部分汇合，</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-35-40.jpg" srcset="/img/loading.gif" alt><br>此时，根据交汇点，将 4 交换到交汇点所在的位置</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-38-27.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>找出一个基准值 base_value，划分小于 base_value 和 大于 base_value:</p><ul><li>从右划分大于的部分，直到某个值小于 base_value，此时划分出的右区间都比 base_value 更大。</li><li>从左边划分小于的部分，直到某个值大于 base_value，此时划分的左区间都比 base_value 更小。</li><li>重复以上两个过程直到左右区间合并，交汇点就是 base_value “应该在”的地方，于是将 base_value 交换到交汇点</li></ul></blockquote><blockquote><p>这样一来，base_value 左边都是小于等于它的，右边都是大于等于它的</p></blockquote><pre><code class="C">int patition(int *arr, int left, int right) {    int base_value = arr[left], tmp, base_pos = left;    while (left &lt; right) {        while (arr[right] &gt;= base_value &amp;&amp; left &lt; right)            --right;        while (arr[left] &lt;= base_value &amp;&amp; left &lt; right)             ++left;        _swap(arr[left], arr[right]);    }    _swap(arr[base_pos], arr[right])    return right;}</code></pre><p>如何划分，在网上有很多种思路，但我不想把重心放在这里。因为我认为重点是“快速排序到底是如何实现排序的”。</p><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>假设数据规模 N</p><h3 id="1-最好"><a href="#1-最好" class="headerlink" title="(1). 最好"></a>(1). 最好</h3><p>最好的情况，每次都是以中位数为基准划分的，递归树接近满二叉树，层数级别 $\log_2 N$，每一层需要将区间首的基准元素交换到左右部分的汇合点，左边小于右边大于，所以需要遍历比较每一个元素，每一层需要遍历 1~ N 个元素，平均 $\frac{N}{2}$ 个元素，所以最好的时间复杂度是 $O(N\log_2N)$。</p><h3 id="2-最差"><a href="#2-最差" class="headerlink" title="(2). 最差"></a>(2). 最差</h3><p>最差的情况，每次都是以最值为基准划分的，递归树接近直线，层数级别 N，每一层平均 $\frac{N}{2}$ 个，解析同上。所以时间复杂度是 O($N^{2}$)。特说明，此时快速排序就成了冒泡排序。</p><h3 id="3-平均"><a href="#3-平均" class="headerlink" title="(3). 平均"></a>(3). 平均</h3><p>平均情况下，时间复杂度处于 $O(N\log_2 N)$ 和 $O(N^{2})$ 之间。《算法导论》中证明了平均性能 $O(N\log_2 N)$，较为复杂。</p><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>就地排序，这部分不考虑；<br>若干变量，left, base, right，因为理想情况下递归深度为 $\log_2 N$ 层，最多 N 层，考虑保存栈中的区间信息，空间复杂度为 O($\log_2 N$)~ O(N)。</p><h1 id="稳定性分析"><a href="#稳定性分析" class="headerlink" title="稳定性分析"></a>稳定性分析</h1><p>快速排序是不稳定的排序，因为元素之间的交换跨越区间，例如每次将基准元素放在 left 以及划分完毕时将 left 元素交换到汇合点，这些都会导致不稳定。</p><h1 id="分析与优化"><a href="#分析与优化" class="headerlink" title="分析与优化"></a>分析与优化</h1><h2 id="1-为什么要从右边开始找起？"><a href="#1-为什么要从右边开始找起？" class="headerlink" title="1. 为什么要从右边开始找起？"></a>1. 为什么要从右边开始找起？</h2><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/20-21-39.jpg" srcset="/img/loading.gif" alt><br>这一点我当初在《啊哈算法》上看到过，只是略微想了想，没想明白。如今回顾（图来自《啊哈算法》）：<br>假设从左边划分小于 6 的数开始，直到 9，发现 9 &gt; 6；再从右边开始划分大于 6 的数字，因为左边区域已经到了 9，所以从右边最多只能划分到 9，汇合点 9！再将 6 交换到汇合点，9 排在了 6 的前面，有问题！<br>问题发生在哪里？从右边开始划分应该一直找到 3 的，但因为左边区域已经囊括了 3，甚至是 9，所以右边只能被迫停在“比 6 更大”的数字 9 上，之后 9 就被交换到了 6 所在的位置。<br>总结一下，最后汇合点的位置一定是先出发那一边找到的值，而汇合点之后要和基准值交换，汇合点的值应该放在左边还是右边就需要注意了：</p><blockquote><ul><li>如果从更小部分开始划分，汇合点的值一定是大于基准值的，要和基准值交换，只要保证基准值在更大的区间</li><li>如果从更大部分开始划分，汇合点的值一定是小于基准值的，要和基准值交换，只要保证基准值在更小的区间</li></ul></blockquote><p>这样一来汇合点就会放在它应该在的部分，就不会有这个问题了。</p><h2 id="2-如何选择基准元素？"><a href="#2-如何选择基准元素？" class="headerlink" title="2. 如何选择基准元素？"></a>2. 如何选择基准元素？</h2><p>从时间复杂度分析可以看出，理想情况下的划分是二分的，也就是说，每次挑选的基准元素是中位数。但如果每次遍历找中位数，会大大增大时间复杂度。是否存在快速寻找中位数的方法呢？或者提供近似中位数的性能？</p><ol><li>无额外信息的情况下，从一个无序序列中找出中位数，时间复杂度至少是 O(N)，因为一定需要扫描每个元素；</li><li>近似中位数？考虑随机，从无序区间中随机选择一个数字作为基准元素。现实性能还不错。<br>为什么呢？</li></ol><blockquote><ul><li>从概率的角度来看，围绕中位数存在一个“甜品区”<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/22-38-04.jpg" srcset="/img/loading.gif" alt><br>如图，中位数 13，围绕 13 左右存在一个甜品区，只要随机数能选到这些“近似中位数”的数，那么一次划分的效果就不会差。假设甜品区占据了整个区间的 $p，0 &lt; p &lt; 1$，那么每次随机选择到“甜品区”的概率就是 $p$，选的值不好的概率就是 $1 - p$——在快速排序的过程中，假设划分次数是 $n，\log_2 N &lt;= n &lt;= N$，选中甜品区的次数是 $m，m &lt;= n$，最差的情况 m = 0，概率为 $(1 - p) ^ {n}$，当 n 足够大时，$(1 - p) ^ {n}$近似为 0，也就是说，几乎不可能很差；最好的情况 m = n，概率为 $p ^ {n}$，当 n 一定时，概率可以不为 0，这说明有可能达到最好的性能，完美的O($N\log_2 N$) 时间复杂度。只要 p 够大，甜品区够大，平均性能还是可以逼近 O($N\log_2 N$) 的。</li><li>从“最大熵”的角度来看，在没有更多约束或更多了解的情况下做最保险、风险最小的决策，假设各种情况概率相等从而实现最大熵。体现在这里就是，我们并不知道中位数是哪个？选择第一个，还是选择第五个，还是选择第……不知道，在没有额外信息的情况下，我们认为每一个位置的数字是中位数的概率是一样的，这样的决策是风险最小的，不仅如此，它的计算量低到 O(1)。这样的思想在遗传进化算法中应用颇多。</li></ul></blockquote><p>随机在统计（大数据）下是具有一定的优势的，这一点我在学习 treap 二叉树时就体会到了，在大数据的均衡下，treap 是近似满二叉树的，原理简单，性能强劲，是我最喜欢的平衡二叉树。</p><h2 id="3-其他划分方法"><a href="#3-其他划分方法" class="headerlink" title="3. 其他划分方法"></a>3. 其他划分方法</h2><p>如何根据基准元素划分成大小两部分有很多方法，网上大多流传“挖坑法”和“指针法”。本质没有复杂度级别上的改变，在此不作赘述。</p><h2 id="4-小区间直接插入排序"><a href="#4-小区间直接插入排序" class="headerlink" title="4. 小区间直接插入排序"></a>4. 小区间直接插入排序</h2><p>老规矩，递归处理小区间时，由于构建堆栈和函数调用的开销，采用简单的排序反而效果很好。是否起效果，期待后续测评。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="C">#include &lt;time.h&gt; #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;stdbool.h&gt;// 宏定义int tmp;#define _swap(a, b) { tmp = a;  a = b;  b = tmp;  }#define _rand(a, b) a + rand() % (b - a + 1)// 区间够短时，采用插入排序会更有效 数据量较大时可以动态调整 small_limit#define small_limit 3void insert_sort(int *arr, const int L); // 常规操作int *get_array(const int L);void free_array(int *arr);void display_array(int *arr, const int L);// 快速排序void quick_sort(int *arr, const int left, const int right);void quick_sort_plus(int *arr, int left, int right);int patition(int *arr, int left, int right);int main() {    srand((int)time(0));     const int L = 12;    int *arr = get_array(L);    quick_sort_plus(arr, 0, L - 1);    display_array(arr, L);    free_array(arr);    return 0;}void quick_sort(int *arr, const int left, const int right) {    if(right - left &lt;= small_limit)        insert_sort(arr + left, right - left + 1);    else {        int base = patition(arr, left, right);        quick_sort(arr, left, base - 1);        quick_sort(arr, base + 1, right);    }}void quick_sort_plus(int *arr, int left, int right) {    int *_stack = (int *)malloc(sizeof(int) * (right - left + 1));    int cnt = -1, base;    _stack[++cnt] = left;    _stack[++cnt] = right;    while(cnt &gt;= 1) {        right = _stack[cnt--];        left = _stack[cnt--];        // 如果区间很短了        if(right - left &lt;= small_limit)            insert_sort(arr + left, right - left + 1);        else {            base = patition(arr, left, right);            if(base + 1 &lt; right) {                _stack[++cnt] = base + 1;                _stack[++cnt] = right;            }            if(left &lt; base - 1) {                _stack[++cnt] = left;                _stack[++cnt] = base - 1;            }        }    }    free(_stack);}int patition(int *arr, int left, int right) {    // 随机选择一个基准元素    int base_pos = _rand(left, right);    _swap(arr[left], arr[base_pos]);    // 更新，现在 arr[left] 存储的是新选择的值    int base_value = arr[left];    base_pos = left;    while (left &lt; right) {        while (arr[right] &gt;= base_value &amp;&amp; left &lt; right)            --right;        while (arr[left] &lt;= base_value &amp;&amp; left &lt; right)             ++left;        if (left &lt; right)            _swap(arr[left], arr[right]);    }    _swap(arr[base_pos], arr[right])    return right;}// 友情客串，插入排序void insert_sort(int *arr, const int L) {    int i, j;    for(i = 1;i &lt; L; ++i) {        tmp = arr[i];        j = i;        while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp) {            arr[j] = arr[j - 1];            --j;        }        arr[j] = tmp;    }}// 输入一个数组, 返回数组首地址int *get_array(const int L) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    for (i = 0; i &lt; L; ++i)        scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free\n&quot;);    }}// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
      <category>分而治之</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(7) 堆排序</title>
    <link href="/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(7)%20%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/12/08/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(7)%20%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>大二学习数据结构时，我还对各种算法（插入、冒泡这些菜鸡就不参与了，太慢）的性能进行了一个评估，一千万的随机数据，进行排序，结果我记得是堆排序最快，在几个指标上都领先，然后是快速排序，紧接着是归并排序（归并排序慢了一倍吧好像）…然而我写的这几个算法都被 STL 库的 sort 暴捶，趁着这次重新学习算法的兴趣，后续我想分析一波 sort 源码。<br>回到堆排序，之前我就提过，堆排序是选择排序的改进版——选择排序，每次从无序集合中找出最小值，时间复杂度O(N)，找 N - 1 次，整体的时间复杂度就成了 O(N * N)；而堆排序就是采用了“堆”这一数据结构将找最值的时间复杂度降成了O(log2N)，从而奠定了它O(Nlog2N)的威名。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一些无需数字，对它们排序，默认从小到大</p><h2 id="堆排序的过程"><a href="#堆排序的过程" class="headerlink" title="堆排序的过程"></a>堆排序的过程</h2><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-7-%E5%A0%86%E6%8E%92%E5%BA%8F/20180710152959504.gif" srcset="/img/loading.gif" alt><br>(图来源于网络)<br>更详细的动图演示可以参考 <a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html" target="_blank" rel="noopener">Data Structure Visualization</a><br>第一遍，我并没有看懂，智商捉急，但看了一些网上的解释，例如：</p><blockquote><p>算法描述</p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。</li><li>不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成</li></ul></blockquote><p>多读几遍，对照图，emm，当初大二也是这么学算法的，可能算笨的，但有效。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>分为两步：构建最大（小）堆 + 堆筛选最值</p><h2 id="构建最值堆"><a href="#构建最值堆" class="headerlink" title="构建最值堆"></a>构建最值堆</h2><p>借助数组的下标索引，从 0 开始到 L - 1，L 是数组长度，左二子 lson = 2 * 当前下标 + 1，rson = 2 * 当前下标 + 2。假设数组长度 12，则堆是这样根据下标存储在数组中的：</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-7-%E5%A0%86%E6%8E%92%E5%BA%8F/13-26-19.jpg" srcset="/img/loading.gif" alt><br>可以看出，但数组中的元素不一定满足最值堆的性质，所以需要调整——自下而上（为什么？因为下标索引左右孩子是 2 * i + 1 和 2 * i + 2），每个元素检查自己的两个孩子，如果孩子中的最大值（以最大堆为例）比本身更大，则孩子和自己需要交换值。但这并没有结束，例如：</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-7-%E5%A0%86%E6%8E%92%E5%BA%8F/13-34-01.jpg" srcset="/img/loading.gif" alt><br>-4 和 两个孩子的值 10、-8 比较，10 比 -8 和 -4 大，所以将 10 和 -4 交换，<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-7-%E5%A0%86%E6%8E%92%E5%BA%8F/13-35-30.jpg" srcset="/img/loading.gif" alt><br>此时并没有结束，-4 继续和自己的两个孩子比较值，发现 6 和 -1 都比自己大，所以将两个孩子中的“更大值”优先调整向上，结果如下：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-7-%E5%A0%86%E6%8E%92%E5%BA%8F/13-37-01.jpg" srcset="/img/loading.gif" alt><br>之后 -4 继续和自己的孩子比较<br>…<br>…<br>…<br>直到 -4 比自己的两个孩子都更大。<br>从上面的过程，也可以说明为什么要自下而上——下方已经调整好的子树都满足堆的性质，才能保证从根节点调整下来的值沿着某条路径依旧保持堆的性质。<br>代码如下：</p><pre><code class="c">void heap_create(int *arr, const int L){    int half = (L - 1) / 2, i;    for(i = half;i &gt;= 0; --i) {        int tmp, max_index, now = i;        while(true) {            if(lson &gt;= L - 1) {                if(lson == L - 1 &amp;&amp; arr[now] &lt; arr[lson])                    _swap(arr[now], arr[lson]);                break;            }            max_index = arr[lson] &gt; arr[rson] ? lson : rson;            if(arr[max_index] &gt; arr[now]) {                _swap(arr[max_index], arr[now]);                now = max_index;            }            else break;        }    }}</code></pre><p>half ? 因为要和两个孩子比较大小，所以从索引一半开始。<br>代码中每次调整都可以视为“针对下标为 now 的元素对堆进行调整，后续完整代码中调整为 maintain 子函数。</p><h2 id="逐个筛选最值"><a href="#逐个筛选最值" class="headerlink" title="逐个筛选最值"></a>逐个筛选最值</h2><p>好了，现在堆结构已经构建好了，可以开始筛选最值，可以采用一个临时数组，每次存储堆顶的最值，然后删除堆顶，调整堆结构——但为了直接在原数组上操作，直接交换 arr[0] 和 arr[当前最后一个数]，然后当前剩余数 - 1；<br>累计  L - 1 次操作即可将整个数组排序。</p><pre><code class="c">// 堆排序void heap_sort(int *arr, const int L) {    int operations = L - 1, tmp;    while(operations &gt; 0) {        _swap(arr[0], arr[operations]);        maintain(arr, 0, operations);        --operations;    }}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>假设数据规模为 N。<br>需要筛选 N - 1 次，<br>每次筛选，需要交换一次值 O(1)，然后将根节点的值向下调整，路径最大长度是 O(log2N)——因为下标是连续存储的，堆的深度depth 满足<br>$$ 2^{depth - 1} &lt; N &lt; 2^{depth} $$<br>所以 depth 是 log2N 级别的。<br>在路径中，每次交换需要三次比较，如果交换则有三次赋值操作，都是常数级别。惊喜的是，实际向下调整的路径很可能 &lt; depth。<br>综上，堆排序的时间复杂度是 O(N * log2N)</p><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>排序直接在原数组上进行，这部分不计算。<br>若干变量，i，tmp，max_index……空间复杂度根据不同写法可以将空间复杂度降为 O(1)。</p><h1 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h1><p>元素交换跨越了区间，当前节点 i 和下标为 2 * i + 1 和 2 * i + 2 的左右孩子存在交换；堆顶元素和最后一个元素交换……堆排序是不稳定的。</p><h1 id="存在的问题与改进等"><a href="#存在的问题与改进等" class="headerlink" title="存在的问题与改进等"></a>存在的问题与改进等</h1><h2 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h2><p>优化？我暂时没想到。<br>空间复杂度已经 O(1)了，精力不应该放在这里；<br>时间复杂度——筛选 N - 1 次，每次 O(log2N)，最多优化常数级别的交换次数或者缩短路径等等。缩短路径？存不存在先对数据分析，具有统计意义上的最小路径和呢？perhaps。</p><h2 id="2-思考"><a href="#2-思考" class="headerlink" title="2. 思考"></a>2. 思考</h2><blockquote><ul><li>将数据结构引入到排序中，直接解决已有算法复杂度太高的问题，这样的方法数不胜数。以前学习排序，我以为就那么 10 来个经典的再加上几个不怎么出名的奇葩，但当我学习数据结构之后，才发现，不少数据结构稍微改一改就能达到 O(Nlog2N) 的效果。</li><li>面试官比较喜欢问的一个经典问题——筛选一个数组中的最小值，或者第几大数等等……堆就是一种很适合的数据结构，每次查询的时间复杂度低到 O(log2N)，筛选 n 次即可找到第几大数或第几小数。</li><li>虽然堆筛选最值方面已经很优秀了，但是它依旧存在很多问题，例如只能在固定的数组上查询，因为堆是构建在其上的，无法迁移到动态区间上，例如我要在 [1, 10] 找第三大值，然后在 [7, 15] 找第三小值，啊哦，堆还无法改变它自身的最值性质，“最大最小”无法兼有。对此的解法，在我记忆里有平衡树(AVL，treap，split_tree…)、线段树等，这几个更是神奇。</li></ul></blockquote><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>为了普遍性，声明了比较函数指针，可以选择构建最大堆或者最小堆。<br>终于体验到了原创代码的好处，之前学习算法，写出的都是模板，都是从网上代码研究修改出来的，这样的代码没意思，只有自己根据思路写出代码，才是真正的“抽象 + 自动化”！<br>嘿嘿，网上的堆调整函数基本都是递归写的，很明了，我写完自己的之后再深入学习时才发现递归可以解决它，茅塞顿开，也按照自己的思路写了递归版，但这样的快乐远不及我自己写出了“非递归”版。<br>不过由于是 C 语言写的，不具有 C++ 的模板特性。经过模板封装的堆更具有普适性，日后回顾堆时再写 C++。</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;stdbool.h&gt;#include &lt;math.h&gt;// 宏定义#define _swap(a, b) { tmp = a;  a = b;  b = tmp; }#define lson 2 * now + 1#define rson 2 * now + 2// 定义比较函数bool _bigger(const int a, const int b) {return a &gt; b;};bool _smaller(const int a, const int b) { return a &lt; b; };typedef bool (*compare_type)(const int a, const int b);// 声明主要函数int *get_array(const int L, const bool _scanf);void free_array(int *arr);void display_array(int *arr, const int L);// 堆排序相关void heap_sort(int *arr, const int L);void heap_create(int *arr, const int L);void maintain(int *arr, int now, const int L, compare_type _compare);void shift_down(int *arr, int now, int L, compare_type _compare);int main() {    const int L = 12;    int *arr = get_array(L, true);    heap_create(arr, L);            // 创建最大堆    heap_sort(arr, L);              // 逐个筛选最小值    display_array(arr, L);    free_array(arr);    return 0;}// 堆排序void heap_sort(int *arr, const int L) {    int operations = L - 1, tmp;    while(operations &gt; 0) {        _swap(arr[0], arr[operations]);        maintain(arr, 0, operations, _bigger);        --operations;    }}// 给定数组 arr，创建堆void heap_create(int *arr, const int L){    int half = (L - 1) / 2, i;    for(i = half;i &gt;= 0; --i)         maintain(arr, i, L, _bigger);}// 维持最大（小）堆的结构void maintain(int *arr, int now, const int L, compare_type _compare) {    int tmp, max_index;    while(true) {        if(lson &gt;= L - 1) {            if(lson == L - 1 &amp;&amp; _compare(arr[lson], arr[now]))                _swap(arr[now], arr[lson]);            break;        }        max_index = _compare(arr[lson], arr[rson]) ? lson : rson;        if(_compare(arr[max_index], arr[now])) {            _swap(arr[max_index], arr[now]);            now = max_index;        }        else break;    }}// 修改之后的递归版本，名字来源于网络，的确很形象void shift_down(int *arr, int now, int L, compare_type _compare) {    int tmp;    if(lson &gt;= L - 1) {        if(lson == L - 1 &amp;&amp; _compare(arr[lson], arr[now]))            _swap(arr[now], arr[lson]);        return;    }    int max_index = _compare(arr[lson], arr[rson]) ? lson : rson;    if(_compare(arr[max_index], arr[now])) {        _swap(arr[max_index], arr[now]);        shift_down(arr, max_index, L, _compare);    }}// 输入一个数组, 返回数组首地址int *get_array(const int L, const bool _scanf) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    if(_scanf == true)        for (i = 0; i &lt; L; ++i)            scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free&quot;);    }}// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(6) 归并排序</title>
    <link href="/2019/11/29/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(6)%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/11/29/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(6)%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>归并排序，几大 O(NlogN) 排序算法之一，也其中是最好理解的排序算法。每次二分，分到可以单独排序，在回溯的过程中不断排序，最后组合得到排好序的数组——“分而治之”。我对分而治之的了解甚少，当初只是理解为“不断递归分解为可解决的子问题”，也仅仅是局限于递归而已。但分而治之不是递归，非递归也可以分而治之，更是五大算法思想之一（分而治之、动态规划、贪心、回溯法、分支界定法）。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一些无需数字，对它们排序，默认从小到大</p><h2 id="归并排序的过程"><a href="#归并排序的过程" class="headerlink" title="归并排序的过程"></a>归并排序的过程</h2><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/10-26-30.jpg" srcset="/img/loading.gif" alt><br>如上，过程很明了，两个部分 “分” 和 “治”。<br>分——处于搜索子问题的阶段，将问题分解为可直接排序的子问题（一个数字就可以直接排序）；<br>治——处于回溯阶段，将子问题综合成最终解。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>首先考虑，如何将原问题多次二分分解为单个元素（可直接得到解）<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/09-46-10.jpg" srcset="/img/loading.gif" alt></p><p>考虑存在回溯的过程，递归的方式:</p><pre><code class="C">void merge_sort(int *const arr, const int left, const int right) {    if(left &lt; right) {        int mid = (left + right) / 2;        merge_sort(arr, left, mid, depth + 1);        merge_sort(arr, mid + 1, right, depth + 1);    }}</code></pre><p>传入一个参数 depth = 1，每次递归参数 depth + 1，即可打印出区间的二分的情况。给定 12 个数据，位于数组区间 [0, 11]<br>    [0, 5]    [6, 11]<br>    &emsp;&emsp;[0, 2]    [3, 5]<br>    &emsp;&emsp;&emsp;&emsp;[0, 1]    [2, 2]<br>    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[0, 0]    [1, 1]<br>    &emsp;&emsp;&emsp;&emsp;[3, 4]    [5, 5]<br>    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[3, 3]    [4, 4]<br>    &emsp;&emsp;[6, 8]    [9, 11]<br>    &emsp;&emsp;&emsp;&emsp;[6, 7]    [8, 8]<br>    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[6, 6]    [7, 7]<br>    &emsp;&emsp;&emsp;&emsp;[9, 10]    [11, 11]<br>    &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[9, 9]    [10, 10]<br>接下来考虑在回溯的过程中<strong>有序合并</strong>子问题，如例子：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/09-44-12.jpg" srcset="/img/loading.gif" alt><br>归并排序每次二分，二分得到子问题，然后再有序合并</p><pre><code class="C">void merge_sort(int *const arr, const int left, const int right) {    if(left &lt; right) {        int mid = (left + right) / 2;        merge_sort(arr, left, mid, depth + 1);        merge_sort(arr, mid + 1, right, depth + 1);        // 有序合并两个区间的元素 [left, mid] [mid + 1, right]        merge(arr, left, mid, right]    }}</code></pre><p>有序合并的函数位置如上。<br>接下来设计有序合并函数 merge。逐个比较<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/10-13-50.jpg" srcset="/img/loading.gif" alt><br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/10-14-36.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/10-15-14.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/10-15-45.jpg" srcset="/img/loading.gif" alt></p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/10-16-08.jpg" srcset="/img/loading.gif" alt><br>……<br>……<br>……</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/10-17-23.jpg" srcset="/img/loading.gif" alt><br>如图，组合两个有序区间 [left, mid] 和 [mid + 1, right] 很简单，设计两个指针分别指向两个区间当前最小值即可。具体代码如下：</p><pre><code class="C">void merge(int *const arr, const int left, const int mid, const int right) {    // 找一个临时数组存储有序结果    const int Len = right - left + 1;    int *temp = (int *)malloc(Len * sizeof(int));    // 分配两个“类指针” i, j 指向当前比较的数字    int i = left, j = mid + 1, cnt = 0;    while(i &lt;= mid &amp;&amp; j &lt;= right) {        if(arr[i] &lt; arr[j])            temp[cnt++] = arr[i++];        else            temp[cnt++] = arr[j++];    }    while(i &lt;= mid) temp[cnt++] = arr[i++];    while(j &lt;= right) temp[cnt++] = arr[j++];    // 将有序结果 “誊抄” 到原数组区间 [left, right]    for(i = 0;i &lt; Len; ++i)        arr[left + i] = temp[i];    free(temp);}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>假设数据规模为 N<br>归并排序属于分而治之的算法，分为两步：<br>分——每次二分，搜索所有可解子问题的（递归）深度为 $ k = \lceil log2N \rceil $<br>治——将子问题的解有序排列在一起，每一次组合经历的计算次数主要为遍历两个子问题已有序的子序列，粗略累计：<br>$$ 2 * \frac{N}{2} + 4 * \frac{N}{4} + …… + 2^{k - 1} * \frac{N}{2 ^ {k - 1}} + N$$<br>共 k - 1 项，每一项计算量 N，故时间复杂度为$ O(Nlog2N) $</p><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>假设数据规模 N<br>程序使用若干临时变量，i, j, cnt等，空间复杂度 O(1)<br>每次都要使用一个临时数组 temp，根据每次合并的区间大小决定，假定 k = log2N ，计算量同上，空间复杂度 O(Nlog2N)。<br>不同写法有不同的空间复杂度，例如将临时数组 temp 设置为全局变量，全程使用，即可将空间复杂度降为 O(N)。</p><h1 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h1><p>根据归并排序的两个过程，<br>分——直到分解为单个数字，都不存在改变逆序的计算；<br>治——有序合并的过程存在改变逆序的操作，若是同一子序列，相同大小的数字合并后前后顺序不变；若是不同子序列，只需要保证，在原数组中排列在前的子序列[left, mid]能 “优先进入” 合并后的数组，体现在代码中：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/07-36-35.jpg" srcset="/img/loading.gif" alt><br>由上两步，即可达到排序稳定的结果。</p><h1 id="存在的问题与改进等"><a href="#存在的问题与改进等" class="headerlink" title="存在的问题与改进等"></a>存在的问题与改进等</h1><p>凡是用递归书写的程序都一定可以用迭代来完成。递归存在函数压栈和退栈的开销，而迭代则不存在这个问题。</p><h2 id="1-非递归优化"><a href="#1-非递归优化" class="headerlink" title="1. 非递归优化"></a>1. 非递归优化</h2><p>具体实现还是遇到了一些小问题，计算过程和递归版有些差异，递归都是二分，但非递归的步长是 2 的倍数，例如<br>15 = 8 + 7 = 8 + 4 + 3 = 8 + 4 + 2 + 1<br>具体思路较为简单。例如 12 个元素的数组，各层的区间划分如下：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/18-02-58.jpg" srcset="/img/loading.gif" alt></p><pre><code class="C">void merge_sort_hierarchy(int *arr, const int L) {    int depth = ceil(log2(L));    int i, step, left, mid, right;    for(i = 0;i &lt; depth; ++i) {        step = 1 &lt;&lt; i;        for(left = 0;left &lt;= L - step; left += 2 * step) {            mid = left + step - 1;            right = _min(mid + step, L - 1);            if(left &lt; right)                 merge(arr, left, mid, right);        }    }}</code></pre><p>还有其他小优化，例如</p><ol><li>递归的排序区间比较短时，使用插入排序、冒泡排序等简单排序效率会更高，因为不需要创建堆栈记录信息；</li><li>左区间 [left, mid] 的最大值都比 [mid + 1, right] 的最小值还要小时，此时根本不需要其他操作，可以直接合并。<br>……<br>对于 O(NlogN) 的算法来说，这些都属于同一层次的优化，只能减少常数级别的计算量。</li></ol><h2 id="2-思考"><a href="#2-思考" class="headerlink" title="2. 思考"></a>2. 思考</h2><p>回想上一篇《希尔排序》的内容，希尔排序有一个特点便是一次元素的交换可以消除多个逆序对，从而可以加快正序的过程，以同样的思路审视归并排序：<br>归并排序在合并两个有序数组的过程中，存在大量消除逆序对的操作，例如：<br>[2 4 7 8] [-4 -3 2]<br>以上两个区间都是有序的，最终结果是<br>[-4 -3 2 2 4 7 8]<br>在归并的过程中， -4 和 -3 都能仅仅通过一次比较就消除四个逆序对，-3 同理。<br>这样跨越区间直接消除逆序对，比插入排序等就快多了；同时归并排序采用二分的形式划分区间，为一次消除多个逆序对创造了条件。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;stdbool.h&gt;#include &lt;math.h&gt;#define _min(a, b) (a &gt; b ? b : a)int *get_array(const int L, const bool _scanf);void free_array(int *arr);void display_array(int *arr, const int L);void merge_sort(int *arr, const int left, const int right);void merge_sort_hierarchy(int *arr, const int L);void merge(int *const arr, const int left, const int mid, const int right);int *temp;int main() {    const int L = 12;    int *arr = get_array(L, true);    temp = get_array(L, false);    merge_sort_hierarchy(arr, L);    display_array(arr, L);    free_array(arr);    free_array(temp);    return 0;}// 归并排序 递归形式void merge_sort(int *arr, const int left, const int right) {    if(left &lt; right) {        int mid = (left + right) / 2;        merge_sort(arr, left, mid);        merge_sort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}// 归并排序 非递归形式 模拟每一层的计算过程void merge_sort_hierarchy(int *arr, const int L) {    int depth = ceil(log2(L));    int i, step, left, mid, right;    for(i = 0;i &lt; depth; ++i) {        step = 1 &lt;&lt; i;        for(left = 0;left &lt;= L - step; left += 2 * step) {            mid = left + step - 1;            right = _min(mid + step, L - 1);            if(left &lt; right)                 merge(arr, left, mid, right);        }    }}// 将两个有序区间再次有序合并void merge(int *const arr, const int left, const int mid, const int right) {    const int Len = right - left + 1;    int *temp = (int *)malloc(Len * sizeof(int));    int i = left, j = mid + 1, cnt = 0;    while(i &lt;= mid &amp;&amp; j &lt;= right)         temp[cnt++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];     while(i &lt;= mid)         temp[cnt++] = arr[i++];    while(j &lt;= right)         temp[cnt++] = arr[j++];    for(i = 0;i &lt; Len; ++i)        arr[left + i] = temp[i];}// 输入一个数组, 返回数组首地址int *get_array(const int L, const bool _scanf) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    if(_scanf == true)        for (i = 0; i &lt; L; ++i)            scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free&quot;);    }}// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
      <category>分而治之</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(12) 特殊排序</title>
    <link href="/2019/11/28/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(12)%20%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/11/28/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(12)%20%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.itcodemonkey.com/article/12948.html" target="_blank" rel="noopener">https://www.itcodemonkey.com/article/12948.html</a></p><h1 id="地精排序"><a href="#地精排序" class="headerlink" title="地精排序"></a>地精排序</h1><h1 id="珠排序"><a href="#珠排序" class="headerlink" title="珠排序"></a>珠排序</h1><h1 id="睡眠排序"><a href="#睡眠排序" class="headerlink" title="睡眠排序"></a>睡眠排序</h1><h1 id="猴子排序"><a href="#猴子排序" class="headerlink" title="猴子排序"></a>猴子排序</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(5) 希尔排序</title>
    <link href="/2019/11/28/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(5)%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/11/28/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(5)%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>对希尔排序的印象不深，数据结构课上讲过，第一个突破O(N * N)的排序算法，时间复杂度是$O(N^{1.3})$，竟然还有指数级别的排序算法，还是小数，相比O(N)的几个排序算法来说，算法性能算不上优秀，相比于 O(N * N)的排序算法来说好一大截，但性能还是不如 O(Nlog2N) 的排序算法，二者的曲线增长趋势相差较大。<br>如今回顾，发现希尔排序在思路上还是很优秀的。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一堆数字，排序</p><h2 id="希尔排序的过程"><a href="#希尔排序的过程" class="headerlink" title="希尔排序的过程"></a>希尔排序的过程</h2><p>(1) 设定间隔 interval = 4，将数组根据间隔分为若干个小序列，每个小序列进行插入排序，最终将结果汇合。<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-5-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/08-08-35.jpg" srcset="/img/loading.gif" alt><br>(2) 设定间隔 interval = 2：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-5-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/08-17-23.jpg" srcset="/img/loading.gif" alt><br>(3) 设定间隔 interval = 1：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-5-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/08-19-05.jpg" srcset="/img/loading.gif" alt><br>排序完毕。<br>插入排序正是 interval = 1 的情况，同时也保证了数组排序的最终结果一定是对的。那直接插入排序不行吗，为什么还要进行 interval = 4、2 的插入排序？<br>之前讨论过，插入排序在数组正序或者基本有序的情况下，时间复杂度是 O(N)，线性！如果能通过一些微调使得数组基本有序，最后再使用插入排序，岂不是能“逐渐”获得接近O(N)的排序性能！<br>希尔排序正是利用了这一点，先将数组分为一些小份，每个小份进行排序（默认插入排序），使得数组基本有序，步长逐渐缩小，最后使用原型的插入排序排序。可见，步长越靠近 1，排序性能理论上越接近 O(N)。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="C">void insert_sort(int *arr, const int L, const int interval) {    int i, j, tmp;    for(i = interval; i &lt; L; i += interval) {        tmp = arr[i];        j = i;        while(j &gt;= interval &amp;&amp; arr[j - interval] &gt; tmp) {            arr[j] = arr[j - interval];            j -= interval;        }        arr[j] = tmp;    }}// 希尔排序void shell_sort(int *arr, const int L, const int intervals[], const int intervals_len) {    int i, j, tmp;    for(i = 0;i &lt; intervals_len; ++i)         for(j = 0;j &lt; intervals[i]; ++j)            insert_sort(arr + j, L - j, intervals[i]);}</code></pre><p>代码中，对插入排序的代码进行了修改，每次排序的数组是根据步长 “提取” 出来的，由 i += interval 操控。<br>来看希尔排序的核心代码：</p><pre><code class="c">for(i = 0;i &lt; intervals_len; ++i)     for(j = 0;j &lt; intervals[i]; ++j)        insert_sort(arr + j, L - j, intervals[i]);</code></pre><p>外层循环，针对每一次步长，intervals_len 是步长个数，4 2 1（也可以是其他的，但必须递减）<br>内层循环，根据步长周期，将数组 “完全” 分开，如图，<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-5-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/08-37-55.jpg" srcset="/img/loading.gif" alt><br>得到 9 开头的小份，2 开头的小份，2开头的小份，-3开头的小份</p><pre><code class="c">insert_sort(arr + j, L - j, intervals[i]);</code></pre><p>arr + j 是控制小份的数组指针，L - j 是控制取出的小份数组不越界。<br>由上可知，每个小份只要能排序即可，不一定是插入排序，冒泡、选择等等都可以，但是需要控制步长 interval 取出小份数组。</p><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>希尔排序时间复杂度的指数具体数值目前是比较模糊的，并没有一个统一的取值，它取决于增量。目前根据特定序列推理出的理论最佳值约为 1.2 ~ 1.3。相关证明可以参考<a href="https://zhuanlan.zhihu.com/p/73726253" target="_blank" rel="noopener">究竟是怎么打破二次时间屏障的？浅谈希尔排序的思想和复杂度证明</a>。</p><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>数组排序结果存储在原数组 arr 上，这部分不计算；<br>使用若干临时变量，i, j, tmp 等，每次取出小份数组，都会产生这些临时变量，假设步长共 S 个，步长平均 A，则根据核心代码，空间复杂度 O(S * A)。<br>不同写法，不同空间复杂度，但给出代码的空间复杂度是 O(S *A)。最佳可以到 O(1)，但是为了体现组件（小份的排序）的作用……</p><h1 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h1><p>当步长 interval = 1，退化为插入排序，此时希尔排序是稳定的；<br>其他情况下，由于数据之间的挪动不是相邻元素之间的，所以，给定一定数据，一定会发生不稳定的情况，希尔排序是不稳定的。</p><h1 id="存在的问题与改进等"><a href="#存在的问题与改进等" class="headerlink" title="存在的问题与改进等"></a>存在的问题与改进等</h1><p>存在的问题？ 本人技拙，暂无想法。</p><h2 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h2><p>网上也给出了一些不痛不痒的优化，例如<br>(1) 没有显式地将数组分成小份，而是直接扫描数组，扫到谁就处理谁所在的“当前”小份的排序。修改后的代码如下：</p><pre><code class="C">void shell_sort_plus(int *arr, const int L, const int intervals[], const int intervals_len) {    int i, j, tmp;    for(i = 0;i &lt; intervals_len; ++i) {        // 直接遍历，轮到谁，就直接对它所在的当前小份进行插入排序        for(j = intervals[i];j &lt; L; ++j) {            tmp = arr[j];            while(j &gt;= intervals[i] &amp;&amp; arr[j - intervals[i]] &gt; tmp) {                arr[j] = arr[j - intervals[i]];                j -= intervals[i];            }            arr[j] = tmp;        }    }}</code></pre><p>原理不变，只是减少了函数堆栈调用以及 for 层数，有利于 CPU 指令优化和缓存优化。<br>(2) 采用更好的步长序列，类似著名的 Hibbard增量<br>(3) 小份里排序，采用更快的排序，或者直接采用插入排序的优化方案。</p><h2 id="2-对我的启发"><a href="#2-对我的启发" class="headerlink" title="2. 对我的启发"></a>2. 对我的启发</h2><p>为什么希尔排序能达到这种效果，看似三层循环，但实际面临大数据性能却大大好过冒泡和选择排序。之前我也一直在思考类似快排、堆排序、归并排序为什么就是和冒泡等O(N * N)的算法有什么本质上的不同，至于是什么，说不清。但再次学习，我看到了一个满意的解释：<br>排序的本质是消除 “逆序”，什么是逆序？ 3 2 就是逆序对。大部分排序都是基于两个数的比较，然后交换位置——插入排序、冒泡排序、选择排序等都是在 “相邻元素” 之间进行比较和交换，每一次交换操作，都只能消除一个逆序（如 3 2 -&gt; 2 3），N 个数据，假设最坏情况下全部逆序，逆序数达到最大 N * (N - 1) / 2，相邻元素的交换需要 N * ( N - 1) / 2 次；但希尔排序不同，希尔排序能跨越地进行元素之间的比较和交换，一次可以消除多个逆序，例如：<br>9 8 5 3 7 -1<br>步长为 5，取出 9 和 -1，一次交换位置，但是消除的逆序有 5 个（9 和 -1，8 和 -1，5 和 -1，3 和 -1，7 和 -1）。<br>从效率上来说，希尔排序消除逆序要快得多，它减少了很多重复无意义的比较（例如步长 8 4 2 1，在步长 8 排序之后，再以步长 4 排序，其中一部分序列是重叠的，而且重叠的部分已经有序了，省略了很多交换）。相比之下，类似插入排序，则需要一个一个比较往前挪，消除相同的逆序，需要 5 次交换。<br>快速排序、归并排序亦是如此，通过比较和交换 “相隔一定距离” 的两个数，一次性可以消除多个逆序。<br>学习希尔排序可谓收获良多，无论是它的设计思路，还是它消除逆序数的方式都充分利用了插入排序的优势。最重要的是，从消除逆序这个角度来看排序，也许能让我对各种排序为什么快为什么慢有更深的理解。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;stdbool.h&gt;#define _swap(a, b) { tmp = a;  a = b;  b = tmp;  }int *get_array(const int L);void free_array(int *arr);void display_array(int *arr, const int L);void insert_sort(int *arr, const int L, const int interval);void shell_sort(int *arr, const int L, const int intervals[], const int intervals_len);void shell_sort_plus(int *arr, const int L, const int intervals[], const int intervals_len);int main() {    const int L = 12;    int *arr = get_array(L);    int intervals[3] = {4, 2, 1};    shell_sort_plus(arr, L, intervals, 3);    display_array(arr, L);    free_array(arr);    return 0;}// 希尔排序void shell_sort(int *arr, const int L, const int intervals[], const int intervals_len) {    int i, j, tmp;    for(i = 0;i &lt; intervals_len; ++i)         for(j = 0;j &lt; intervals[i]; ++j)            insert_sort(arr + j, L - j, intervals[i]);}// 间隔为 interval 的插入排序void insert_sort(int *arr, const int L, const int interval) {    int i, j, tmp;    for(i = interval; i &lt; L; i += interval) {        tmp = arr[i];        j = i;        while(j &gt;= interval &amp;&amp; arr[j - interval] &gt; tmp) {            arr[j] = arr[j - interval];            j -= interval;        }        arr[j] = tmp;    }}// 希尔排序的加强版void shell_sort_plus(int *arr, const int L, const int intervals[], const int intervals_len) {    int i, j, tmp;    for(i = 0;i &lt; intervals_len; ++i) {        // 直接遍历，轮到谁，就直接对它所在的当前小份进行插入排序        for(j = intervals[i];j &lt; L; ++j) {            tmp = arr[j];            while(j &gt;= intervals[i] &amp;&amp; arr[j - intervals[i]] &gt; tmp) {                arr[j] = arr[j - intervals[i]];                j -= intervals[i];            }            arr[j] = tmp;        }    }}// 输入一个数组, 返回数组首地址int *get_array(const int L) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    for (i = 0; i &lt; L; ++i)        scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free&quot;);    }}// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(4) 插入排序</title>
    <link href="/2019/11/26/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(4)%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/11/26/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(4)%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>插入排序，当初大一学的时候总是写不对控制变量，究其原因——思路不清晰，根本没理解插入排序。慕然回首，惊了！<br>竟然是整理扑克牌！<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/22-05-17.jpg" srcset="/img/loading.gif" alt></p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一堆数字，排序，默认从小到大</p><h2 id="插入排序的过程"><a href="#插入排序的过程" class="headerlink" title="插入排序的过程"></a>插入排序的过程</h2><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/insertionSort.gif" srcset="/img/loading.gif" alt><br>每次将一个数移动到 “有序集合” 的适当位置，使得原 “有序集合” 仍然有序。<br>思路：整理扑克牌，哈哈</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="C">void insert_sort(int *arr, const int L) {    int i, j, tmp;    for(i = 1;i &lt; L; ++i) {        tmp = arr[i];        j = i;        while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp) {            arr[j] = arr[j - 1];            --j;        }        arr[j] = tmp;    }}</code></pre><p>L　个数字，有序放到 L 个位置，只需要将其中 L - 1 个数字摆好位置，就排好序了，所以外层循环共 L - 1 次。i 从 1 开始主要是i = 0 时一个数不需要重新整理。<br>内层循环就是不断往前交换，找适当的位置，摆放好数字。回想整理扑克牌的过程， 首先我会记住要整理的这张牌，大小是 tmp，然后我要从这张牌的前面的牌 j - 1 开始找起，如果前面的牌 arr[j - 1] 比 tmp 更大，就把前面的牌往后挪，这样一直找下去……直到前面的牌 j’ - 1 已经 &lt;= tmp 了，说明 tmp 找到了要插入的位置 j’，把 j’ 处的牌换成 tmp，arr[j] = tmp。哈哈，突然变得简单了，只要捋清楚整理过程，控制条件还是很好写的。</p><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>假设数据规模 N，<br>外层循环至少要整理 N - 1 次<br>内层循环：<br>(1)最坏情况，逆序(5 4 3 2 1)，每次调整都要经历最大次数的挪动，总共挪动次数 (N - 1) + (N - 2) + …… + 2 + 1 = $\frac{N * (N - 1)}{2}$ 次，N - 1 次调整，平均挪动 $\frac{N}{2}$ 次。<br>(2) 最好情况，正序(1 2 3 4 5)，每次调整都不需要往后挪动牌，总共挪动次数 0，计算判断条件等时间复杂度 O(1)。<br>因此，插入排序的时间复杂度，最好是 O(N)，最坏情况下是 O(N ^ N)。</p><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>排序结果存储于原数组，这部分不计算。<br>使用若干临时变量，i, j, tmp，空间复杂度 O(1)。<br>因此，插入排序的空间复杂度是 O(1)</p><h1 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h1><p>每次要整理的牌是 tmp，我要往前找 &lt;= tmp 的位置 j - 1，第一次遇到这个位置（有序集合中最后一个有可能等于 tmp 的位置），就把 tmp 插入到 j - 1 的后面。所以说，相同的数字，经过插入排序后，原先在前面的数字依旧在前面，因此，插入排序是稳定的。<br>这也与写法有关，如果内层循环终止条件是往前找 &lt; tmp 的位置 j - 1，写法就是 while(j &gt; 0 &amp;&amp; arr[j - 1] &gt;= tmp)，循环终止，找到的是有序集合中第一个有可能等于 tmp 的位置的前面，这时候，插入排序是不稳定的。很明显，这种写法明显需要比较更多的次数才能找到次数。既然可以稳定，为什么要写成不稳定呢？所以，默认插入排序是稳定的。<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/08-40-50.jpg" srcset="/img/loading.gif" alt><br>给定如上例字，把 3 插入到有序集合{ -4 1 3 3 3 3 7 9 }中，有两种找法，无疑绿色箭头指向的位置消耗的时间更少，而且相同数字的前后顺序不变</p><h1 id="存在的问题与改进"><a href="#存在的问题与改进" class="headerlink" title="存在的问题与改进"></a>存在的问题与改进</h1><p>按照插入排序的过程，整理 N 个数据，至少需要 N - 1 次插入，这个没法优化（如果这个都优化了，那就不是插入排序了，基本思路不能变）。<br>那么优化的过程就在于怎么样最快找到插入的位置、怎么样加快挪动甚至消除挪动。</p><h2 id="1-二分搜索优化"><a href="#1-二分搜索优化" class="headerlink" title="1. 二分搜索优化"></a>1. 二分搜索优化</h2><p>首先考虑怎么样最快找到插入的位置，目标是有序集合。很自然就能想到二分查找（折半查找），大一就接触过它了，玩法真是多变（递归，第一个大于等于，第一个小于……)。<br>为了保持插入排序的稳定性，二分查找目标可以是，第一个大于 tmp 的数在哪里。</p><pre><code class="C">// 在数组的 [l, r] 区间内二分查找 “第一个大于 value” 的位置int binary_search(int *arr, int l, int r, const int value){    int mid = -1;    while(l &lt;= r) {        mid = (l + r) &gt;&gt; 1;        if(arr[mid] &gt; value) r = mid - 1;        else if(arr[mid] &lt;= value) l = mid + 1;    }    return l;}void insert_sort(int *arr, const int L) {    int i, j, tmp, index;    for(i = 1;i &lt; L; ++i) {        tmp = arr[i];        index = binary_search(arr, 0, i - 1, tmp);        for(j = i;j &gt; index; --j)            arr[j] = arr[j - 1];        arr[j] = tmp;    }}</code></pre><p>对于当前要插入有序集合的数 tmp，二分查找 binary_search 找到第一个大于 tmp 的数在 index，于是将 [index, i - 1] 的数都挪动到 [index + 1, i]，最后再把 tmp 填入 index 处。<br>如何二分找到第一个大于 value 的位置，关键就是改变几个控制条件与返回值。<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/10-18-33.jpg" srcset="/img/loading.gif" alt><br>二分搜索是经典算法问题，后续我将整理整理，以后就不会怕它了，哈哈。<br>虽然二分搜索可以加速查找插入的位置，但是还有以下几个问题：<br>(1) 找到了插入位置之后，挪动数据的时间复杂度依旧是 O(N * N)，所以插入排序的时间复杂度依旧是 O(N * N)。<br>(2) 二分搜索只有在面对大区间搜索时才具有优势，如果数据量不多，频繁地取中值点、比较中值点数大小等操作，使用二分搜索反而会更慢，还不如直接遍历来的快。<br>直观理解：假设查找的有序区间长度为 $2^{20}$，第一次二分，可以减少的搜索区间长度是 $2^{19}$；第二次二分，可以减少的搜索区间长度是 $2^{18}$……第 18 次二分，可以减少的搜索区间长度是 $2^{2}$；第 19 次二分，可以减少的搜索区间长度是 $2^{1}$……可以看出，区间越短，二分搜索能节约的计算就越少（指数递减），在短区间内执行几次取中值点、比较中值点数大小还不如直接遍历。<br>因此，可以采取折中的策略：当查找地有序区间长度 &gt; 某个阈值，例如 $2^{5}$，就采用二分搜索；否则，直接遍历找插入点。但阈值最佳是多少？没有定论。</p><h2 id="2-跳表-skip-list"><a href="#2-跳表-skip-list" class="headerlink" title="2. 跳表 skip-list"></a>2. 跳表 skip-list</h2><p>以下内容涉及一些数据结构，接受不了可以直接跳过这一小节。<br>二分搜索未能解决数据挪动带来的巨大开销，这是数组的 “连续存储” 特性导致的。那就得寻找 “非连续存储” 的数据结构。<br>最简单的 “非连续存储” 数据结构就是链表，插入的时间复杂度为 O(1)，不存在数据挪动的问题。但是链表不存在下标访问，只能一个连一个访问，在搜索上的时间复杂度是 O(N)，即使链表存储的是有序数据，也不能使用二分搜索。此时我的脑海中冒出了一幅图<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/11-10-01.jpg" srcset="/img/loading.gif" alt><br>跳表，Skiplist，链表的 “魔改” 版，通过在节点上存储额外的跳转信息，使得链表能够跳跃地访问数据，查找性能接近二分搜索，一次查找时间复杂度O(log2N)，而且跳表地跳转距离不是严格的 2 的指数，而是随机的，更加自由。更加惊喜的是，跳表在构建本身（不断插入数据）的时候就已经对数据排好序了，时间复杂度 O(Nlog2N)，接近快排、归并等著名排序算法。跳表篇幅较长，在此不做介绍。</p><h2 id="3-桶排序？"><a href="#3-桶排序？" class="headerlink" title="3. 桶排序？"></a>3. 桶排序？</h2><p>什么？ 要找到插入的位置？ 桶排序原理也许是某种插入排序！给定要插入的数 tmp，通过哈希定位到它应该在的位置，前后看看离哪个数字最近，就插在它前面(或后面)吧，最后“一眼望去”排队就排在它前面(或后面)。这种插入时间复杂度 O(1)。</p><p>也有一些其他的小优化，例如 while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp) 比较了两次，成本有点高? excuse me ? 对于“吹毛求疵”的做法，例如把 j &gt; 0 去掉，用数组的某一位替代 tmp，进一步节约 tmp……我不反对，哈哈。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;stdbool.h&gt;#define _swap(a, b) { tmp = a;  a = b;  b = tmp;  }int *get_array(const int L);void free_array(int *arr);void display_array(int *arr, const int L);void insert_sort(int *arr, const int L);void insert_sort_plus(int *arr, const int L);int binary_search(int *arr, int l, int r, const int value);int main() {    freopen(&quot;input.in&quot;, &quot;r&quot;, stdin);    const int L = 12;    int *arr = get_array(L);    insert_sort_plus(arr, L);    display_array(arr, L);    free_array(arr);    return 0;}// 插入排序void insert_sort(int *arr, const int L) {    int i, j, tmp;    for(i = 1;i &lt; L; ++i) {        tmp = arr[i];        j = i;        while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp) {            arr[j] = arr[j - 1];            --j;        }        arr[j] = tmp;    }}// 基于二分搜索的插入排序void insert_sort_plus(int *arr, const int L) {    int i, j, tmp, index;    for(i = 1;i &lt; L; ++i) {        tmp = arr[i];        index = binary_search(arr, 0, i - 1, tmp);        for(j = i;j &gt; index; --j)            arr[j] = arr[j - 1];        arr[j] = tmp;    }}// 在数组的 [l, r] 区间内二分查找 “第一个大于 value” 的位置int binary_search(int *arr, int l, int r, const int value){    int mid = -1;    while(l &lt;= r) {        mid = (l + r) &gt;&gt; 1;        if(arr[mid] &gt; value) r = mid - 1;        else if(arr[mid] &lt;= value) l = mid + 1;    }    return l;}// 输入一个数组, 返回数组首地址int *get_array(const int L) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    for (i = 0; i &lt; L; ++i)        scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free&quot;);    }}// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(3) 选择排序</title>
    <link href="/2019/11/26/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(3)%20%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/11/26/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(3)%20%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>选择排序的思路可以说是最简单的了，每次找到最小值或者最大值，相对于冒泡排序来说，没有那么多交换的过程。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一堆数字，排序</p><h2 id="选择排序的过程"><a href="#选择排序的过程" class="headerlink" title="选择排序的过程"></a>选择排序的过程</h2><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/selectionSort.gif" srcset="/img/loading.gif" alt><br>思路：每次在剩余数中找最值。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="C">void select_sort(int *arr, const int L) {    int min_index, i = 0, j = 0, tmp;    for(i = 0;i &lt; L - 1; ++i) {        min_index = i;        for(j = i + 1;j &lt; L; ++j)             if(arr[j] &lt; arr[min_index])                 min_index = j;        if(i != min_index)             _swap(arr[i], arr[min_index]);    }}</code></pre><p>每次找出一个最小值，L 个数据只需要 L - 1 次筛选，故外层循环控制条件是 i &lt; L - 1。<br>找最小值的过程中，使用一个变量 min_index 存储 “当前最小值” 的下标，一轮找过之后，如果找到的最小值下标 min_index 不是当前下标值，交换值，将最小值归纳到 “最小值集合”。</p><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>假设数据规模 N，内层循环的 if 判断 if(arr[j] &lt; arr[min_index]) 共计算了 $$ (N - 1) + (N - 2) + ……. + 2 + 1 = \frac{ (N - 1) * N }{2} $$次，如果进入 if 分支，则计算量 * 2；<br>外层循环的 if 判断 if(i != min_index) 共计算了 $ N - 1 $ 次，如果进入 if 分支，计算量 * 4，因为 _swap 操作三次。<br>即使最好的情况，数据正序(1 2 3 4 5)，都不进入 if 分支，计算量也是 $\frac{ (N - 1) * N }{2} + N - 1 = \frac{ (N + 1) * N }{2} - 1$。<br>因此，时间复杂度是 $O(N * N)$。</p><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>最终结果依旧保存在原始数组，故这部分不计算；<br>使用了包括 min_index 在内的几个临时变量，空间复杂度 O(1)；这也和临时变量所处的环境有关，代码中 tmp 是处于 _swap 外，所以空间复杂度O(1)；如果选用库中的 swap，空间复杂度就是 O(N)，因为库函数中的临时变量在 swap 内部，每调用一次就销毁一次。<br>因此，空间复杂度是 $O(1)$。</p><h1 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h1><p>问题在于选择排序的交换操作，可以不是相邻元素之间的交换，中间相隔的元素就带来了不稳定性。例如<br>给定数据 $3^{‘}$ -7 $3^{‘’}$ 1 -4<br>第一轮选择：[-7] [$3^{‘}$ $3^{‘’}$ 1 -4]<br>第二轮选择：[-7 -4] [$3^{‘’}$ 1 $3^{‘}$]<br>可以发现，第二轮，由于 -4 和 $3^{‘}$ 的交换，使得 $3^{‘}$ 和中间相隔元素$3^{‘’}$ 的前后关系改变了。因此，选择排序不是稳定排序。<br>相比之下，冒泡排序的元素交换是相邻元素之间的，所以不存在这样的问题。</p><h1 id="存在的问题与改进"><a href="#存在的问题与改进" class="headerlink" title="存在的问题与改进"></a>存在的问题与改进</h1><h2 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h2><p>仔细看选择排序的过程，N 规模的数据要排序肯定要找 N - 1 次，这个没法优化；那么优化就应该在于如何最快找到最值。<br>后续将会讲到的堆排序就是利用了堆这一数据结构的性质，快速找到最值，其从 N 规模的数据中找最值时间复杂度是 O(log2N)，当 N 多达亿万级别，平均计算 20-30 次即可找到最值。但它也是付出了空间的代价，利用了大量构建的额外信息才能不断缩小计算的范围。<br>普通找最值还是需要遍历。网上流行的选择排序优化则是 “双向” 加快找最值的过程，因为每次遍历剩余的数据只找一次最小值（举例），不太划算，要充分利用 for 循环的遍历，除了找最小值，我还要找最大值，当“最小值集合” 和 “最大值集合” 开始有交集的时候，说明已经排好序了。</p><pre><code class="C">void select_sort_bidirectional(int *arr, const int L) {    int min_index, max_index, l, r, t, tmp;    for(l = 0, r = L - 1;l &lt; r; ++l, --r) {        min_index = l;        max_index = r;        for(t = l;t &lt;= r; ++t) {            if(arr[t] &lt; arr[min_index])                min_index = t;            if(arr[t] &gt; arr[max_index])                max_index = t;        }        if(min_index != l)             _swap(arr[l], arr[min_index]);        // 如果找到的最大值刚刚恰好在 l 处，被替换了成了 arr[min_index]        if(max_index == l)             max_index = min_index;        if(max_index != r)             _swap(arr[r], arr[max_index]);    }}</code></pre><p>基本思想和原来没有区别，控制一下 “最小值集合” 和 “最大值集合” 的汇集条件。需要注意的就是三次 _swap，如果第一次 swap 刚好替换掉了找到的最大值(max_index == l的情况)，就要把找到的最大值 “换回来”。<br>两边一起找，外层循环计算变成了原来的一半，时间复杂度级别仍然是$O(N)$；内层循环的计算 (N - l) 次，共 N + (N - 2) + (N - 4) + …… 共 N / 2 项，时间复杂度级别还是 $O(N)$ 。外层循环多了两次 if 判断和一次 _swap、一次赋值，影响并不大。因此时间复杂度整体上还是 O(N * N)，计算量减少了。<br>优化并不是很明显，毕竟时间复杂度从级别上来说还是不变的。但这种双向搜索的思想还是很重要的，类似的有双向深度优先搜索、双向广度优先搜索等。</p><h2 id="2-和冒泡排序的比较"><a href="#2-和冒泡排序的比较" class="headerlink" title="2. 和冒泡排序的比较"></a>2. 和冒泡排序的比较</h2><p>两者有很大的共同处：每次都是从 “无序集合” 中筛选最值，筛选的最值归入 “有序集合”<br>不同：选择排序每次寻找最值都没有交换过程，而是找到最值索引后才开始交换；冒泡排序在每次寻找最值的过程中在断断续续地交换（冒泡），更新当前最大值。体现在代码的区别就是，选择排序的交换在外循环，冒泡排序的交换在内循环——冒泡排序的交换更频繁，操作相对更多。<br>孰优孰劣？ 从交换次数来说，选择排序直观上相对更少，但是选择排序每次筛选都只移动一次元素；冒泡排序每次筛选，冒泡的较大的值都会相应地靠近 “有序集合”，使得后续移动的操作更少……具体还需大量数据评测。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define _swap(a, b) { tmp = a;  a = b;  b = tmp;  }int *get_array(const int L);void free_array(int *arr);void display_array(int *arr, const int L);void select_sort(int *arr, const int L);void select_sort_bidirectional(int *arr, const int L);int main() {    const int L = 12;    int *arr = get_array(L);    select_sort_bidirectional(arr, L);    display_array(arr, L);    free_array(arr);    return 0;}void select_sort(int *arr, const int L) {    int min_index, i = 0, j = 0, tmp;    for(i = 0;i &lt; L - 1; ++i) {        min_index = i;        for(j = i + 1;j &lt; L; ++j)             if(arr[j] &lt; arr[min_index])                 min_index = j;        if(i != min_index)             _swap(arr[i], arr[min_index]);    }}// 双向选择排序void select_sort_bidirectional(int *arr, const int L) {    int min_index, max_index, l, r, t, tmp;    for(l = 0, r = L - 1;l &lt; r; ++l, --r) {        min_index = l;        max_index = r;        for(t = l;t &lt;= r; ++t) {            if(arr[t] &lt; arr[min_index])                min_index = t;            if(arr[t] &gt; arr[max_index])                max_index = t;        }        if(min_index != l)             _swap(arr[l], arr[min_index]);        // 如果找到的最大值刚刚恰好在 l 处，被替换了成了 arr[min_index]        if(max_index == l)             max_index = min_index;        if(max_index != r)             _swap(arr[r], arr[max_index]);    }}// 输入一个数组, 返回数组首地址int *get_array(const int L) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    for (i = 0; i &lt; L; ++i)        scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free&quot;);    }}// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(2) 冒泡排序</title>
    <link href="/2019/11/26/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(2)%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/11/26/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(2)%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>冒泡排序是入门级的排序算法。当初大一学习它，只是简单地记住了它的代码，用时则写，对于为什么它叫做“冒泡排序”、为什么循环控制条件是 N - 1 和 N - i - 1，为什么比较的是 j 和 j + 1 而不是 i 和 i + 1 没有深刻的理解。这并不是学习算法该有的样子，只会模板，不会根据已有思路创造算法。这样的习惯，导致了我算法基础极其不牢固，代码能力弱。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一堆数字，排序</p><h2 id="冒泡排序的过程"><a href="#冒泡排序的过程" class="headerlink" title="冒泡排序的过程"></a>冒泡排序的过程</h2><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/bubbleSort.gif" srcset="/img/loading.gif" alt><br>动图可以说是十分形象了。每次从头筛选一个最大值放到剩余数末尾，冒泡排序就是这么简单。中间的交换过程是为了将最大值往后推；并不是每一次都需要交换，当需要交换时，就是“冒泡”的时刻，整个过程看起来就像是冒泡。<br>思路：每次从头筛选一个最大值放到剩余数的末尾。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="C">void bubble_sort(int *arr, const int L) {    int i, j, tmp;    for(i = 0;i &lt; L - 1; ++i)         for(j = 0;j &lt; (L - i) - 1; ++j)            if(arr[j] &gt; arr[j + 1])                _swap(arr[j], arr[j + 1]);}</code></pre><p>每次筛选一次最大值嘛，筛选 L - 1 次就能对 L 个数排好序，所以外层循环代表多少趟。<br>第 i 趟，已经筛选出的最大值有 i 个，剩余 L - i 个数。从 L - i 个数中选出最大值需要 (L - i) - 1 次比较，所以内层循环控制条件是 &lt; (L - i) - 1。<br>每次筛选的过程，都会更新 “当前最大值” ，呈现 “冒泡” 的现象。</p><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>假设数据规模 N, 执行判断共：<br> $$(N - 1) + (N - 2) + … + 2 + 1 = \frac{N * (N - 1)}{2} $$次，<br>最好的情况，没有交换发生，$\frac{N * (N - 1)}{2}$<br>最坏的情况，每次都交换，_swap 三次操作，$3 * \frac{N * (N - 1)}{2}$<br>故，时间复杂度$ O(N * N)$</p><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>因为最终结果还是存储在原数组中，这部分不计算；<br>使用 3 个临时变量 i, j, tmp， 空间复杂度 $O(1)$<br>故，空间复杂度 $O(1)$<br>（修改 _swap 函数强制将空间复杂度降为 0 是会出问题的）</p><h1 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h1><p>由于冒泡排序交换的条件是 arr[j] &gt; arr[j + 1]，所以，相同值的数字之间的前后关系不会改变。因此，冒泡排序是稳定排序。</p><h1 id="存在的问题与改进"><a href="#存在的问题与改进" class="headerlink" title="存在的问题与改进"></a>存在的问题与改进</h1><h2 id="1-添加排序标志位"><a href="#1-添加排序标志位" class="headerlink" title="1. 添加排序标志位"></a>1. 添加排序标志位</h2><p>乍看之下，除了时间复杂度 $O(N * N)$ 有点碍眼之外，代码如此简洁明了，实在找不出啥问题。但还是有大佬将最佳时间复杂度优化成 O(N) 了……</p><pre><code class="c">void bubble_sort(int *arr, const int L) {    int i, j, tmp;    bool swapped = false;    for(i = 0;i &lt; L - 1; ++i) {        swapped = false;        for(j = 0; j &lt; L - (i + 1); ++j)            if(arr[j] &gt; arr[j + 1]) {                _swap(arr[j], arr[j + 1]);                swapped = true;            }        if(swapped == false)            return;         }}</code></pre><p>乍看之下，就增加了一个布尔变量 swapped。如代码所示，第 i 趟筛选最大值时，如果没有发生交换，说明是正序，<br>1 2 3 4 5<br>就是正序，这种情况下剩余的数不需要排序，之前筛选的最大值也排好序。的确可以节约很多计算，当 i &lt;&lt; N，i 十分小时，时间复杂度就是 O(i * N) ≈ O(N)！<br>但是有条件：剩余的数是正序，或者基本排好序了，就能提前结束。<br>有问题吗？<br>从算法正确性上来说，这种改进是没问题的。但是从算法优化上来说，还是存在问题的：<br>(1) 如果数据是逆序的(5 4 3 2 1 这种)或者基本逆序，那么 swapped 就失去了它的作用，因为每次筛选最大值都一定会发生交换，比如<br>5 4 3 2 1<br>第一次：[4 3 2 1] [5]<br>第二次: [3 2 1] [4 5]<br>第三次: [2 1] [3 4 5]<br>…<br>可以看出，每次 swapped 都一定是 true，不会提前返回.<br>(2) 增加了临时变量 swapped 的操作和最坏情况下的计算量。外层循环每次都要对swapped 赋值，N - 1 次；内层循环如果每次都 _swap，那么操作就是 4 次，比原来的 3 次多了一次，最坏情况下的时间复杂度变成了 4 * N * (N - 1) / 2，对于 N 规模到达千万甚至亿级别来说，增加了计算量。<br>(3) 每次外层循环都加入了一次 if 判断，判断这轮是否发生了交换。引入 if 会增加开销吗？<br>会。因为每次找最大值需要计算判断条件 if(swapped == false)，不过在这里增加的开销很小，只是判断 bool 型变量；如果计算判断条件开销很大，那就要考虑了。再者，在这里，即使进入了 if 分支，也只是根据跳转指令返回到 bubble_sort 的调用点而已，不涉及到 if 对多层循环的影响。</p><blockquote><p>扩展：<br>如果代码有多个 if else 判断，最好选择 switch。因为 if else 判断是都要执行的，直到满足条件，中间有一个遍历的操作；而 switch case 类似于一个查表的操作，时间复杂度O(1)，一次到位，是一种空间换时间的做法。<br>if else 在多层循环、流水线操作时，还是会引入很多不确定因素的，深入可以继续查阅相关资料——if 与指令重排、流水线等内容。</p></blockquote><p>当然算法的重点不应当在 if 优化上，而应当在算法整体上的优化，比如降低时间复杂度等方面。再考虑到现代编译器的优化，也许不需要考虑这些， 但是最好知道。<br>…<br>…<br>…<br>虽然存在一些小问题，但是改进的冒泡排序还是有很适用的应用场景的，利用它高效率的特点：数据正序或者基本正序。<br>考虑以下场景：<br>快速排序基本是以递归形式运行的。当程序运行到递归的子问题，处理的数据很少，在这回溯的过程中，数据已经基本有序了，这时候采用冒泡排序就有优势，因为函数递归调用开销较大，直接采用简单的排序反而效果可能会更好。</p><h2 id="2-鸡尾酒排序"><a href="#2-鸡尾酒排序" class="headerlink" title="2. 鸡尾酒排序"></a>2. 鸡尾酒排序</h2><p>这个排序算法是针对冒泡排序做出的小改进，所以并不在八大排序算法之列。本质还是冒泡排序，只是每一轮冒泡，最大值冒一次，最小值也冒一次，双向冒泡，看起来冒泡次数缩短了一半（每次能找出两个元素加入有序集合），每次冒泡的操作加了一倍，看似没有优化。<br>考虑以下数据，采用冒泡排序：<br>2 3 4 5 6 7 1<br>第一次冒泡：2 3 4 5 6 1 [7]<br>第二次冒泡：2 3 4 5 1 [6 7]<br>第三次冒泡：2 3 4 1 [5 6 7]<br>…<br>第六次冒泡：[1 2 3 4 5 6 7]<br>观察以上过程，每次冒泡都只发生了一次交换，都只能将 1 往前推一位，总共经过 6 次冒泡才排好序。<br>鸡尾酒排序对以上数据排序：<br>第一次冒泡：2 3 4 5 6 1 [7] (最大值冒泡 -&gt;)<br>          [1] 2 3 4 5 6 [7] (最小值冒泡 &lt;-)<br>第二次冒泡：没有交换发生<br>排序结束！只经历了两次冒泡。总的交换次数不变，但冒泡次数大大减少</p><pre><code class="c">// 鸡尾酒排序，双向的冒泡排序void bubble_sort_bidirectional(int *arr, const int L) {    int left = 0, right = L - 1, t, tmp;    while(left &lt; right) {        for(t = left; t &lt; right; ++t)             if(arr[t] &gt; arr[t + 1])                _swap(arr[t], arr[t + 1]);        --right;        for(t = right; t &gt; left; --t)            if(arr[t] &lt; arr[t - 1])                _swap(arr[t], arr[t - 1]);        ++left;    }}</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>大一学 C 语言时，特别讨厌这种将函数声明写在前面，函数体写在 main 之后的形式。现在看来，还是有可取之处的，也不是那么难看。<br>但是意义不大，因为实际项目中，函数声明都在头文件 .h 和 .hpp 中，根本不影响，main 还是很简洁的。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define _swap(a, b) { tmp = a; a = b; b = tmp; }int *get_array(const int L);void free_array(int *arr);void display_array(int *arr, const int L);void bubble_sort(int *arr, const int L);void bubble_sort_plus(int *arr, const int L);void bubble_sort_bidirectional(int *arr, const int L);int main() {    freopen(&quot;input.in&quot;, &quot;r&quot;, stdin);    const int L = 12;    int *arr = get_array(L);    bubble_sort_bidirectional(arr, L);    display_array(arr, L);    free_array(arr);    return 0;}// 冒泡排序void bubble_sort(int *arr, const int L) {    int i, j, tmp;    for(i = 0;i &lt; L - 1; ++i)         for(j = 0; j &lt; (L - i) - 1; ++j)            if(arr[j] &gt; arr[j + 1])                 _swap(arr[j], arr[j + 1]);}// 添加了标志位的冒泡排序void bubble_sort_plus(int *arr, const int L) {    int i, j, tmp;    bool swapped = false;    for(i = 0;i &lt; L - 1; ++i) {        swapped = false;        for(j = 0; j &lt; (L - i) - 1; ++j)            if(arr[j] &gt; arr[j + 1]) {                _swap(arr[j], arr[j + 1]);                swapped = true;            }        if(swapped == false)            return;         }}// 鸡尾酒排序，双向的冒泡排序void bubble_sort_bidirectional(int *arr, const int L) {    int left = 0, right = L - 1, t, tmp;    while(left &lt; right) {        for(t = left; t &lt; right; ++t)             if(arr[t] &gt; arr[t + 1])                _swap(arr[t], arr[t + 1]);        --right;        for(t = right; t &gt; left; --t)            if(arr[t] &lt; arr[t - 1])                _swap(arr[t], arr[t - 1]);        ++left;    }}// 输入一个数组, 返回数组首地址int *get_array(const int L) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    for (i = 0; i &lt; L; ++i)        scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free&quot;);    }}// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
      <tag>冒泡排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(1) 桶排序</title>
    <link href="/2019/11/25/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(1)%20%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/11/25/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(1)%20%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>说起排序算法，我最先想到的就是桶排序了，《啊哈算法》上的第一个算法，当初学习时，顿感神奇！这种直接定位到下标的技术(哈希)在日后更是常见，用的好可以降低一个级别的时间复杂度。<br>当时，我已了解到的排序算法如冒泡排序、插入排序、选择排序，快速排序等，都有一个明显比较大小的过程，但是桶排序没有，桶排序直接定位到它应该在哪里，然后…</p><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/16-26-24.jpg" srcset="/img/loading.gif" alt></p><!-- ![16-26-24](16-26-24.jpg) --><!-- http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/ --><!--  --><!--  --><!-- https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/ --><p>就没有然后了，一眼望去，排好了。<br>后续接触，才发现《啊哈算法》上讲的桶排序其实是桶范围 = 1的特殊情况（称“计数排序”），其他情况还是需要比较的过程的，但是我还是把书上讲的当作真的桶排序，谁让我对它那么熟悉呢，哈哈。<br>正文开始。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一堆数字，排序</p><h2 id="桶排序过程："><a href="#桶排序过程：" class="headerlink" title="桶排序过程："></a>桶排序过程：</h2><p>以下过程并非严格的“桶排序”，只是按照《啊哈算法》上的内容设计<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/21-35-44.jpg" srcset="/img/loading.gif" alt><br>第一个数字 2， 放到坐标为 2 的桶上，<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/21-44-03.jpg" srcset="/img/loading.gif" alt><br>第二个数 7，放到坐标为 7 的桶上，<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/21-44-19.jpg" srcset="/img/loading.gif" alt><br>第三个数 1，放到坐标为 1 的桶上，<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/21-44-40.jpg" srcset="/img/loading.gif" alt><br>.<br>.<br>.<br>若干次 “放” 之后，<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/21-45-53.jpg" srcset="/img/loading.gif" alt><br>接下来就是“一眼望去”，扫描一遍，即可得到结果：<br>    0 1 2 2 2 3 4 4 4 5 6 7<br>第一次看到这个排序，我就惊了！ 这么巧妙！原理很简单，就是根据数本身，放到下标为数本身的桶里，再扫描一遍即可得到排序之后的结果。<br>虽然原理很简单，但是代码实现还是有一些需要注意的问题，例如负数 -3 不能放到下标为 -3 的桶，因为数组坐标必须 &gt;= 0，所以区间需要偏移，等等。<br>主要操作： 定位 + 一眼望去</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="CPP">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#define INF INT_MAX#define EMPTY 0// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}// 输入一个数组, 返回数组首地址int *get_array(const int L) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    for (i = 0; i &lt; L; ++i)        scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;        printf(&quot;\nallocated memory is free&quot;);    }}// 从一个 int 数组中找出最小值和最大值, arr 数组地址, _min 最小值地址, _max 最大值地址void get_min_max(int *arr, const int L, int *_min, int *_max) {    int i = 0;    for (i = 0; i &lt; L; ++i) {        if (*_min &gt; arr[i]) *_min = arr[i];        else if (*_max &lt; arr[i]) *_max = arr[i];    }}// 桶排序, arr 数组指针, L 数组长度void bucket_sort(int *arr, const int L) {    // 先找出所有数的范围区间，例如所有数都处在 [-3, 7] 之间    int _min = INF, _max = -INF, i = 0;    get_min_max(arr, L, &amp;_min, &amp;_max);    // 根据区间大小, 摆好恰好足够的桶, 如果 [-3, 7] 就需要 11 个桶    int bucket_size = _max - _min + 1;    int bucket[bucket_size];    for (i = 0; i &lt; bucket_size; ++i) // 所有桶一开始都是空的        bucket[i] = EMPTY;    // 开始放到桶里，注意将区间偏移到 [0, ] 以 0 开始    for (i = 0; i &lt; L; ++i)        ++bucket[arr[i] - _min];      // arr[i] - _min 偏移，例如 -3 偏移到 0, 7 偏移到 10    int cnt = 0, j = 0;    // 开始扫描所有桶    for (i = 0; i &lt; bucket_size; ++i)        // 桶不是空的        if (bucket[i] != EMPTY)            // 这个桶里有多少个数，全部填充到数组中            for (j = 0; j &lt; bucket[i]; ++j) {                arr[cnt++] = i + _min;                // cnt 记录当前，从桶中看到了多少个数，cnt 最终一定是 L            }}int main() {    const int L = 12;    int *arr = get_array(L);    bucket_sort(arr, L);    display_array(arr, L);    free_array(arr);    return 0;}</code></pre><h1 id="扩大桶的“管理”范围"><a href="#扩大桶的“管理”范围" class="headerlink" title="扩大桶的“管理”范围"></a>扩大桶的“管理”范围</h1><p>以上内容都是基于《啊哈算法》设计的。真正的桶排序，原理与上面类似，但是桶的“管理范围”更大，例如：<br>桶的管理范围是 10<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/23-09-28.jpg" srcset="/img/loading.gif" alt><br>桶排序之后：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/23-12-11.jpg" srcset="/img/loading.gif" alt><br>同样很简单！将数字映射到 10 的整数倍的桶中，然后每个桶有桶内的排序，这个桶内排序可以任意选，冒泡、插入… 和之前的差别就是在，每个桶里可以放多个不一样的。<br>三个主要操作：定位 + 桶内排序 + 一眼望去<br>代码<strong>主要代码</strong>修改如下，略显复杂，<strong>若接受不了可直接跳过</strong>，直接复杂度分析。</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#define INF INT_MAX#define EMPTY 0                              // 桶是否为空#define BIG_DATA 1e4                         // 数据规模大的分水岭，大于则用快速排序，小于用冒泡排序#define _range 10                            // 每个桶的管辖范围是 10 ，例如 [20, 29]#define _swap(a, b) {tmp = a; a = b; b = tmp;}typedef int (*map_type)(const int);          // 映射函数类型，函数指针typedef void (*sort_type)(int *, const int); // 排序函数类型, 函数指针，参数：数组指针，数组长度// 打印一个 int 数组，arr 数组指针，L 数组长度void display_array(int *arr, const int L) {    int i = 0;    for (i = 0; i &lt; L; ++i)        printf(&quot;%d &quot;, arr[i]);    printf(&quot;\n&quot;);}// 输入一个数组, 返回数组首地址int *get_array(const int L) {    int i = 0;    int *arr = (int *)malloc(L * sizeof(int));    for (i = 0; i &lt; L; ++i)        scanf(&quot;%d&quot;, &amp;arr[i]);    return arr;}// 释放数组 arrvoid free_array(int *arr) {    if (arr != NULL) {        free(arr);        arr = NULL;    }}// 从一个 int 数组中找出最小值和最大值, 返回映射后的区间长度// arr 数组地址, L 数组长度, _min 起始地址指针int get_min_max(int *arr, const int L, int *_min, map_type _map) {    int _max = -INF, i = 0;    for (i = 0; i &lt; L; ++i) {        if (*_min &gt; arr[i]) *_min = arr[i];        else if (_max &lt; arr[i]) _max = arr[i];    }    return _map(_max - *_min) + 1;}// 映射函数, 桶的管辖范围是 10, 例如 3, 5 都被分到 0 号桶, 35 被分到 3 号桶int map_function(const int data) {    return data / _range;}// 冒泡排序void bubble_sort(int *arr, const int L) {    int i = 0, j = 0, tmp = 0;    for (i = 0; i &lt; L - 1; ++i)        for (j = 0; j &lt; L - i - 1; ++j)            if (arr[j] &gt; arr[j + 1])                _swap(arr[j], arr[j + 1]);}// 快速排序，暂未写到这里，暂时空着void quick_sort(int *arr, const int L) {}// 桶排序, arr 数组指针, L 数组长度void bucket_sort(int *arr, const int L, map_type _map, sort_type inner_sort[]) {    int i = 0, init_addr = INF;    // 求区间大小, 传入 &amp;init_addr 得到区间起始地址    const int bucket_size = get_min_max(arr, L, &amp;init_addr, _map);    // bucket_count 统计每个桶内的数字个数    int bucket_count[bucket_size];    for (i = 0; i &lt; bucket_size; ++i)        bucket_count[i] = EMPTY;    for (i = 0; i &lt; L; ++i)        ++bucket_count[_map(arr[i] - init_addr)];    // bucket 二维数组，但是“残缺”的二维数组；C 语言没有 vector，所以略嫌麻烦    int *bucket[bucket_size];    for (i = 0; i &lt; bucket_size; ++i){        // 如果下标为 i 的桶内有数字，就分配 bucket_count 个 int 的内存        if (bucket_count[i] != EMPTY)            bucket[i] = (int *)malloc(bucket_count[i] * sizeof(int));        else            bucket[i] = NULL;    }    // now[i] 累计坐标 i 的桶内现在放了多少个数字了，初始化为 0    int now[bucket_size];    for (i = 0; i &lt; bucket_size; ++i)        now[i] = 0;    for (int i = 0; i &lt; L; ++i) {        int index = _map(arr[i] - init_addr);        if (bucket[index] != NULL)            bucket[index][now[index]++] = arr[i];    }    // 开始对每个桶内进行排序    for (int i = 0; i &lt; bucket_size; ++i) {        if (bucket[i] != NULL) {            // 桶内排序，数据规模太大用快速排序，数据规模小用冒泡排序；可自己修改            if(bucket_count[i] &gt; BIG_DATA)                inner_sort[1](bucket[i], bucket_count[i]);            else inner_sort[0](bucket[i], bucket_count[i]);        }    }    // 一眼望去，将所有桶的数据装入 arr, 每个桶都通过 inner_sort 排好序了    int cnt = 0, j = 0;    for (i = 0; i &lt; bucket_size; ++i)        if (bucket[i] != NULL)            for (j = 0; j &lt; now[i]; ++j)                arr[cnt++] = bucket[i][j];    // 千万别忘记释放桶动态申请的内存    for(i = 0;i &lt; bucket_size; ++i)        free_array(bucket[i]);}int main() {    const int L = 12;    int *arr = get_array(L);    sort_type sort_functions[2] = {bubble_sort, quick_sort};    // 采用映射函数 map_function 定位到具体某个桶，桶内采用 sort_functions 排序函数组    bucket_sort(arr, L, map_function, sort_functions);    display_array(arr, L);    free_array(arr);    return 0;}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>最早接触时间复杂度就是从冒泡排序开始的，两层循环嘛，每一层都是 N 级别的，所以时间复杂度是O(N * N)。<br>桶排序分为三个步骤，定位 + 桶内排序 + 一眼望去。<br>(1) 定位操作一般是O(1)，每个数据都要定位一次，时间复杂度O(N)，N 是数据规模，如果数据是字符串则需另算字符串平均长度。<br>(2)桶内也需要排序，可以是任何一种排序（桶排序也可以，就是别递归了），一般所有桶的排序算法一致，也可以不一样——桶内数据规模太大的可以选归并排序和堆排序、快速排序这些，桶内数据稀疏的可以选冒泡排序这些，桶排序的稳定性也由选择的排序算法决定。<br>假设桶内排序算法采用快速排序：<br>数据规模 N，共 K 个桶，平均每个桶 N / K 个数据，每个桶内快速排序的时间复杂度就是 (N / K)log2(N / K)，共 K 个桶的时间复杂度就是 K * (N / K)log2(N / K) = Nlog2(N / K)——当 N ≈ K 时，时间复杂度 O(N) ! </p><!-- # $ O(log_2{3}) $ --><p>其他桶内排序算法计算时间复杂度与上面类似。<br>(3)一眼望去，扫描所有桶，时间复杂度 O(K)，K 是桶的个数。<br>所以桶排序的时间复杂度是 O(N) + O(桶内排序算法的复杂度) + O(K)，N 是数据个数，K 是桶的个数。</p><blockquote><p>《啊哈算法》书上介绍的就是桶管理范围为 1 的情况，此时桶内都是同一个数据，不需要桶内排序，时间复杂度平均下来 O(N + K)；最好的情况 N &gt;&gt; K，数据很集中，时间复杂度 ≈ O(N) ，竟然有 O(N) 的排序算法，可惜有限制条件——桶范围 1，N &gt;&gt; K；最差的情况，数据不集中，空间浪费多，接下来，空间复杂度分析，</p></blockquote><h2 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2. 空间复杂度"></a>2. 空间复杂度</h2><p>若干个和 bucket_size 有关的数组，数据规模 K<br>如果最终数组存储在临时数组中，数据规模为 N，使用一个大小为 N 的数组，空间复杂度是 O(N)，故空间复杂度是 O(N + K)<br>如果最终数组存储在原数组中（如代码），则空间复杂度只有 O(K)</p><h1 id="缺点与注意点"><a href="#缺点与注意点" class="headerlink" title="缺点与注意点"></a>缺点与注意点</h1><h2 id="1-存在空间浪费"><a href="#1-存在空间浪费" class="headerlink" title="1. 存在空间浪费"></a>1. 存在空间浪费</h2><p>很明显，桶排序需要构建于某个区间内，如果数据分布不集中，区间长度多达百万、千万，但排序的数据个数很少（几十几百），扫描了太多的空桶，但其实这些桶是不必要遍历的，那么桶排序就失去了它的优势。根本原因就是数组的下标的连续递增性，导致了必须存储这些不必要的桶。如下，总共两个数字，但是需要的桶……<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/10-29-27.jpg" srcset="/img/loading.gif" alt><br>难道数组下标还能不连续递增吗？数组下标当然是连续递增的了。但是 C++ 中，有 map、unordered_map 的存在，它们实现了：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/09-59-24.jpg" srcset="/img/loading.gif" alt><br>arr 并不是数组，但它却具有类似下标访问的性质，重要的是，它的下标可以不连续啊！就不存在浪费的桶。怎么做到的？ 请搜索 <strong>C++ 重载[]操作符</strong>。</p><h2 id="2-可能不稳定"><a href="#2-可能不稳定" class="headerlink" title="2. 可能不稳定"></a>2. 可能不稳定</h2><p>这涉及到<strong>排序稳定性</strong>的概念（深入请搜索），通俗来说，两个一样的数字，在排好序之后的序列中相对前后位置不变，举个例子：<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/10-18-11.jpg" srcset="/img/loading.gif" alt><br>根据年龄排序，结果，刘畅依旧排在钟某前面。<br>概念很简单。<br>桶排序是稳定排序吗？<br>当 bucket_size 桶大小为 1，只能容纳一个数字，那么桶排序是稳定排序，因为同一个数字的桶中，不存在排序，顺序读就已经排好序了<br>当 bucket_size 桶达小 &gt; 1，可以容纳多个数字，那么桶内的排序算法就决定了桶排序的稳定性——如果桶内排序是稳定的，比如冒泡，那么这时的桶排序就是稳定的；如果桶内排序是快速排序，那么此时桶排序就是不稳定的。</p><h2 id="3-数据类型的变化"><a href="#3-数据类型的变化" class="headerlink" title="3. 数据类型的变化"></a>3. 数据类型的变化</h2><p>由上可知，int 数据比较适合桶排序排序。字符串，甚至其他数据类型都可能可以用桶排序排序，只要改变映射函数，能实现字符串到下标的映射，即可；桶内函数组也能对字符串排序即可。</p><h2 id="4-不方便对结构体排序"><a href="#4-不方便对结构体排序" class="headerlink" title="4. 不方便对结构体排序"></a>4. 不方便对结构体排序</h2><p>由于桶排序首先的操作就是哈希，定位在哪个桶；而其他排序算法都有直接比较的过程，对结构体排序，只需要重载 &lt; 操作符，或者书写比较函数 cmp 即可。<br>对于结构体排序这个问题来说，桶排序多了一个定位的操作，需要定义映射函数，作为比较函数的参数（映射利用了坐标的特性，排了序）；还需要定义桶内排序函数……有点复杂，这也许是标准库中没有加入桶排序的原因吧，哈哈。</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="1-动态内存"><a href="#1-动态内存" class="headerlink" title="1. 动态内存"></a>1. 动态内存</h2><p>为什么要选择 malloc 申请动态数组？ C 语言中，直接声明的数组是存储在栈的，栈的内存也就若干 MB，存储能力有限，但现实工程中面临的排序操作可能是几百万甚至几亿的数据，比如 google 搜索，从海量数据中筛选出前 100 个排好序的候选网页，排序数据不可能存储在栈，为了程序后续面临的压力测试，数据最好存储在堆，也就是动态申请的数组中。<br>至于 free 操作，动态申请的内存当然要释放了。内存释放问题大吗？平常我写程序没有 free 也没有任何问题，但是工程应用中没有 free 意味着内存泄漏，意味着内存浪费，也意味着服务器“越来越满”，一满就无法继续服务，必须通过重启等强制措施让操作系统来回收这些内存，服务器一停……很多相应服务都要中断，损失并不小。<br>但是内存真的每次都能正常释放吗？<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-1-%E6%A1%B6%E6%8E%92%E5%BA%8F/09-36-27.jpg" srcset="/img/loading.gif" alt><br>如图，在动态申请内存和释放内存之间有这两个子函数，如果其中有个函数崩溃了（你懂的，越界之类的），那么程序直接结束！ 不会再执行 free_array 操作，意味着内存泄露！<br>那面对这种突发情况怎么处理呢？请搜索 <strong>RAII</strong> 或者 <strong>Scopeguard</strong>，深入学习还可以搜索 <strong>“异常安全”</strong> ，这些概念对于培养良好的编程思维颇有益处，对我来说影响很大。</p><h1 id="性能测评"><a href="#性能测评" class="headerlink" title="性能测评"></a>性能测评</h1><p>见后续排序 总结，敬请期待。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>这从一个数(也可以是其他数据)，直接映射到某个位置上的操作，是哈希。哈希在解决很多问题上能提供O(1)的定位操作，大大降低时间复杂度，但同时也是一种空间换时间的做法。<br>尽管桶排序的作者并不是从哈希出发的，抑或是根本没有作者，这么简单，很多人都能想到，只是像我这样的菜鸡一直陷在“如何比较大小”这个圈里，没有跳出来。后来当我了解到一些特殊二叉树（如线段树，treap，Splay等），每次搜索第 1 小数，搜索N次，就排好序了，平均时间复杂度O(NlogN)，实在感叹灵感的重要性。<br>之后在和一些同学交流时，我发现他们根本就不知道“桶排序”这个东西，心里有点失望；上网一查，八大排序算法竟然没有桶排序一席之地……<br>桶排序算是对我的算法启蒙，它让我感觉到了算法的神奇之处，简单而强大，包括之后学习的并查集、树状数组等等……我有必要对它进行一次整理。<br>虽然我已经大四了，但当我回顾这些知识，它们依旧是那么有趣。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序(10) 总结</title>
    <link href="/2019/11/25/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(10)%20%E6%80%BB%E7%BB%93/"/>
    <url>/2019/11/25/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F(10)%20%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>代码集合  <a href="https://github.com/YHLelaine/AlgorithmYHL" target="_blank" rel="noopener">github</a></p><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>排序问题是个很经典的计算机问题，目标是根据一定的优先级将更重要的数据呈现给人们。例如，在搜索引擎中，给定关键词“希尔排序”，服务器需要汇集并将所有记录按照相关性、时间先后等关键码来排序。用户最希望得到的当然是越相关越好。尽管新的研究方向，例如带有知识的搜索引擎，不再提供多条有序记录供用户挑选而是直接提供最标准的一条答案(夸克浏览器这方面做得还可以)，但排序依旧在很多领域都有广泛的应用。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F-10-%E6%80%BB%E7%BB%93/10-21-06.jpg" srcset="/img/loading.gif" alt><br>(<em>图片来源于网络</em>)<br>以上就是经典的十大排序，说法不一。但可以分为以上两类，其中非比较排序，个人以为可以命名为“借助哈希的排序”，因为它们都利用了类似哈希的方法直接定位或者分级，和其他基于比较的排序不同。<br>当然也存在其他的排序算法，如地精排序、猴子排序等，抑或是基于数据结构性质的排序，后续将另外回顾。<br>以下简单小结以下</p><h2 id="1-交换排序"><a href="#1-交换排序" class="headerlink" title="1. 交换排序"></a>1. 交换排序</h2><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h2><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h2><h2 id="5-借助哈希的排序"><a href="#5-借助哈希的排序" class="headerlink" title="5. 借助哈希的排序"></a>5. 借助哈希的排序</h2><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/10-26-55.jpg" srcset="/img/loading.gif" alt></p><h2 id="测评结果"><a href="#测评结果" class="headerlink" title="测评结果"></a>测评结果</h2><p>机器：Intel(R) Core(TM) i7-7800X CPU @ 3.50GHz 单核<br>数据：测试数据从 1000 ~ 10000000(一亿的数据排序会被操作系统 kill)<br>例如对数据量 1000000 来说，共测试 20 次，每次随机生成 1000000 的数据，每个排序算法都用同样的数据排序，最终结果取 20 次的平均值：</p><blockquote><p>————- 1000 ————<br>快速排序 递归版 平均 0.000168 秒<br>快速排序 非递归版       平均 0.000102 秒<br>堆排序 递归版   平均 0.000264 秒<br>堆排序 非递归版 平均 0.000243 秒<br>归并排序 递归版 平均 0.000167 秒<br>归并排序 非递归版       平均 0.000163 秒<br>基数排序        平均 0.000254 秒<br>希尔排序        平均 0.000031 秒<br>————- 10000 ————<br>快速排序 递归版 平均 0.000977 秒<br>快速排序 非递归版       平均 0.000532 秒<br>堆排序 递归版   平均 0.001543 秒<br>堆排序 非递归版 平均 0.001362 秒<br>归并排序 递归版 平均 0.000925 秒<br>归并排序 非递归版       平均 0.000936 秒<br>基数排序        平均 0.001170 秒<br>希尔排序        平均 0.000182 秒<br>————- 100000 ————<br>快速排序 递归版 平均 0.011687 秒<br>快速排序 非递归版       平均 0.006153 秒<br>堆排序 递归版   平均 0.017624 秒<br>堆排序 非递归版 平均 0.016182 秒<br>归并排序 递归版 平均 0.010709 秒<br>归并排序 非递归版       平均 0.010780 秒<br>基数排序        平均 0.011726 秒<br>希尔排序        平均 0.001844 秒<br>————- 1000000 ————<br>快速排序 递归版 平均 0.138595 秒<br>快速排序 非递归版       平均 0.070004 秒<br>堆排序 递归版   平均 0.214633 秒<br>堆排序 非递归版 平均 0.181442 秒<br>归并排序 递归版 平均 0.122603 秒<br>归并排序 非递归版       平均 0.121853 秒<br>基数排序        平均 0.118053 秒<br>希尔排序        平均 0.018433 秒<br>————- 10000000 ————<br>快速排序 递归版 平均 1.603169 秒<br>快速排序 非递归版       平均 0.801579 秒<br>堆排序 递归版   平均 2.504835 秒<br>堆排序 非递归版 平均 2.062779 秒<br>归并排序 递归版 平均 1.403398 秒<br>归并排序 非递归版       平均 1.403273 秒<br>基数排序        平均 1.184784 秒<br>希尔排序        平均 0.185075 秒<br>————- 100000000 ————<br>Killed<br><img src="/images/algorithms/%E6%8E%92%E5%BA%8F/15-57-00.jpg" srcset="/img/loading.gif" alt></p></blockquote><!-- ![](/images/algorithms/排序/排序-10-总结/15-57-00.jpg) --><h1 id="测评代码"><a href="#测评代码" class="headerlink" title="测评代码:"></a>测评代码:</h1><p>为了符合统一的格式与语言，代码较之前略微有些改变，基本写法不变。</p><pre><code class="cpp">#include &lt;math.h&gt;#include &lt;time.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;int tmp;#define _swap(a, b) { tmp = a;  a = b;  b = tmp;  }void insert_sort(int *arr, const int L); // 快速排序 辅助参数和函数#define _rand(a, b) a + rand() % (b - a + 1)// 快速排序 递归版void quick_sort(int *const arr, const int left, const int right);int patition(int *const arr, int left, int right);// 快速排序 非递归版void quick_sort_plus(int *const arr, const int left, const int right);// 堆排序 辅助参数和函数#define lson 2 * now + 1#define rson 2 * now + 2bool _bigger(const int a, const int b) {return a &gt; b;};bool _smaller(const int a, const int b) { return a &lt; b; };typedef bool (*compare_type)(const int a, const int b);// 堆排序 递归版void heap_sort(int *const arr, const int left, const int right);void shift_down(int *arr, int now, int L, compare_type _compare);void heap_create(int *arr, const int L, bool recursive);// 堆排序 非递归版void heap_sort_plus(int *const arr, const int left, const int right);void maintain(int *arr, int now, const int L, compare_type _compare);void shift_down(int *arr, int now, int L, compare_type _compare);// 归并排序 辅助参数和函数#define _min(a, b) (a &gt; b ? b : a)int *temp;// 归并排序 递归版void merge_sort(int *const arr, const int left, const int right);void merge(int *const arr, const int left, const int mid, const int right);// 归并排序 非递归版void merge_sort_plus(int *const arr, const int left, const int right);// 基数排序static const int radix = 10; // 基数int radix_size;  // 按照基数划分需要收集多少趟static double radix_arr[100]; // 预先计算好每一位的最低值并存储void radix_sort(int *const arr, const int left, const int right);int regulation(int *const arr, const int L);void init_radix();int get_bucket_pos(const int value, const int level);int get_max_len(const int *const arr, const int L);// 希尔排序static const int intervals_len = 7;static int intervals[7] = {1, 4, 13, 40, 121, 364, 1093};void shell_sort(int *arr, const int left, const int right);// 定义排序函数指针typedef void (*sort_type)(int *const, const int, const int);// 验证算法正确性bool validate(const int* const arr, const int L);// 获取随机数据void get_rand_data(int *const arr, const int _size);// 求均值double _mean(const double* const arr, const int L);// qsort 的比较函数int _comp(const void * a, const void * b);int main() {    // 开始评测各种排序的性能    char sort_names[10][30] = {        &quot;快速排序 递归版&quot;, &quot;快速排序 非递归版&quot;,         &quot;堆排序 递归版&quot;, &quot;堆排序 非递归版&quot;,        &quot;归并排序 递归版&quot;, &quot;归并排序 非递归版&quot;,        &quot;基数排序&quot;,        &quot;希尔排序&quot;,    };    sort_type sort_functions[10] = {        quick_sort, quick_sort_plus,         heap_sort, heap_sort_plus,          merge_sort, merge_sort_plus,        radix_sort,        shell_sort    };    // 随机种子    srand((int)time(0));     // 记录，每一种算法，每组数据消耗的时间    double time_cost[10][30];    time_t _begin, _end;    // 参与排序的个数    const int sort_size = 8;    // 20 组数据，取均值    const int times = 20;    for (int d = 3; d &lt;= 8; ++d) {        const int data_size = ceil(pow(10, d));        printf(&quot;\n------------- %d ------------\n&quot;, data_size);        int *arr = (int *)malloc(sizeof(int) * data_size);        for (int t = 0;t &lt; times; ++t) {            get_rand_data(arr, data_size);            for (int i = 0;i &lt; sort_size; ++i) {                _begin = clock();                sort_functions[i](arr, 0, data_size - 1);                _end = clock();                if(!validate(arr, data_size)) {                    printf(&quot;算法 %s 不正确!\n&quot;, sort_names[i]);                    continue;                }                const double _cost = difftime(_end, _begin) * 1.0 / 1e6;                time_cost[i][t] = _cost;                // printf(&quot;%s  --------&gt;  %f\n&quot;, sort_names[i], _cost);            }            _begin = clock();            // qsort(arr, data_size, sizeof(int), _comp);            // _end = clock();            // const double _cost = difftime(_end, _begin) * 1.0 / 1e6;            // printf(&quot;qsort  --------&gt;  %f\n&quot;, _cost);        }        for (int i = 0;i &lt; sort_size; ++i)             printf(&quot;%s\t平均 %f 秒\n&quot;, sort_names[i], _mean(time_cost[i], times));        free(arr);    }    return 0;}/*Intel(R) Core(TM) i7-7800X CPU @ 3.50GHz快速排序 递归版 平均 1.652735 秒快速排序 非递归版       平均 0.794745 秒堆排序 递归版   平均 2.505640 秒堆排序 非递归版 平均 2.084499 秒归并排序 递归版 平均 1.424166 秒归并排序 非递归版       平均 1.400288 秒基数排序        平均 1.184911 秒希尔排序        平均 0.186596 秒*/// 验证排序算法的正确性bool validate(const int* const arr, const int L) {    for (int i = 1;i &lt; L - 1; ++i) {        if(arr[i] &lt; arr[i - 1])            return false;    }    return true;}// 获取随机数据void get_rand_data(int *const arr, const int _size) {    const int left = 0, right = INT_MAX;    for (int i = 0;i &lt; _size; ++i)        arr[i] = left + rand() % right;}// 求均值double _mean(const double* const arr, const int L) {    double ans = 0.0;    for (int i = 0;i &lt; L; ++i)         ans += arr[i];    return ans / L;}// 插入排序，以下有些排序会调用它void insert_sort(int *arr, const int L) {    int i, j;    for(i = 1;i &lt; L; ++i) {        tmp = arr[i];        j = i;        while(j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp) {            arr[j] = arr[j - 1];            --j;        }        arr[j] = tmp;    }}// qsort 的比较函数int _comp(const void * a, const void * b) {    return ( *(int*)a - *(int*)b );}// --------------------------------  快速排序 --------------------------------------void quick_sort(int *const arr, const int left, const int right) {    if(right - left &lt;= 100)        insert_sort(arr + left, right - left + 1);    else {        int base = patition(arr, left, right);        quick_sort(arr, left, base - 1);        quick_sort(arr, base + 1, right);    }}int patition(int *const arr, int left, int right) {    // 随机选择一个基准元素    int base_pos = _rand(left, right);    _swap(arr[left], arr[base_pos]);    // 更新，现在 arr[left] 存储的是新选择的值    int base_value = arr[left];    base_pos = left;    while (left &lt; right) {        while (arr[right] &gt;= base_value &amp;&amp; left &lt; right)            --right;        while (arr[left] &lt;= base_value &amp;&amp; left &lt; right)             ++left;        if (left &lt; right)            _swap(arr[left], arr[right]);    }    _swap(arr[base_pos], arr[right])    return right;}void quick_sort_plus(int *const arr, const int left, const int right) {    int *_stack = (int *)malloc(sizeof(int) * (right - left + 1) * 2);    int cnt = -1, base, l = left, r = right;    _stack[++cnt] = l;    _stack[++cnt] = r;    while(cnt &gt;= 1) {        r = _stack[cnt--];        l = _stack[cnt--];        if(right - left &lt;= 100)            insert_sort(arr + left, right - left + 1);        else {            base = patition(arr, l, r);            if(base + 1 &lt; r) {                _stack[++cnt] = base + 1;                _stack[++cnt] = r;            }            if(l &lt; base - 1) {                _stack[++cnt] = l;                _stack[++cnt] = base - 1;            }        }    }    free(_stack);}// --------------------------------  堆排序 --------------------------------------void heap_sort(int *const arr, const int left, const int right) {    heap_create(arr, right - left + 1, true);    int operations = (right - left + 1) - 1;    while(operations &gt; 0) {        _swap(arr[0], arr[operations]);        shift_down(arr, 0, operations, _bigger);        --operations;    }}// 堆排序 非递归版void heap_sort_plus(int *arr, const int left, const int right) {    heap_create(arr, right - left + 1, false);    int operations = (right - left + 1) - 1;    while(operations &gt; 0) {        _swap(arr[0], arr[operations]);        maintain(arr, 0, operations, _bigger);        --operations;    }}// 给定数组 arr，创建堆void heap_create(int *arr, const int L, bool recursive){    int half = (L - 1) / 2, i;    if(recursive == true) {        for(i = half;i &gt;= 0; --i)             shift_down(arr, i, L, _bigger);        return;    }    for(i = half;i &gt;= 0; --i)         maintain(arr, i, L, _bigger);}// 维持最大（小）堆的结构void maintain(int *arr, int now, const int L, compare_type _compare) {    int max_index;    while(true) {        if(lson &gt;= L - 1) {            if(lson == L - 1 &amp;&amp; _compare(arr[lson], arr[now]))                _swap(arr[now], arr[lson]);            break;        }        max_index = _compare(arr[lson], arr[rson]) ? lson : rson;        if(_compare(arr[max_index], arr[now])) {            _swap(arr[max_index], arr[now]);            now = max_index;        }        else break;    }}// 修改之后的递归版本，名字来源于网络，的确很形象void shift_down(int *arr, int now, int L, compare_type _compare) {    if(lson &gt;= L - 1) {        if(lson == L - 1 &amp;&amp; _compare(arr[lson], arr[now]))            _swap(arr[now], arr[lson]);        return;    }    int max_index = _compare(arr[lson], arr[rson]) ? lson : rson;    if(_compare(arr[max_index], arr[now])) {        _swap(arr[max_index], arr[now]);        shift_down(arr, max_index, L, _compare);    }}// ---------------------------- 归并排序 ------------------------------------void merge_sort(int *const arr, const int left, const int right) {    if(left &lt; right) {        int mid = (left + right) / 2;        merge_sort(arr, left, mid);        merge_sort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}// 非递归void merge_sort_plus(int *const arr, const int left, const int right) {    const int L = right - left + 1;    int depth = ceil(log2(L));    int i, step, mid, l = left, r = right;    for(i = 0;i &lt; depth; ++i) {        step = 1 &lt;&lt; i;        for(l = 0;l &lt;= L - step; l += 2 * step) {            mid = l + step - 1;            r = _min(mid + step, L - 1);            if(l &lt; r)                 merge(arr, l, mid, r);        }    }}// 将两个有序区间再次有序合并void merge(int *const arr, const int left, const int mid, const int right) {    const int Len = right - left + 1;    int *temp = (int *)malloc(Len * sizeof(int));    int i = left, j = mid + 1, cnt = 0;    while(i &lt;= mid &amp;&amp; j &lt;= right)         temp[cnt++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];     while(i &lt;= mid)         temp[cnt++] = arr[i++];    while(j &lt;= right)         temp[cnt++] = arr[j++];    for(i = 0;i &lt; Len; ++i)        arr[left + i] = temp[i];}// ---------------------------- 基数排序 ------------------------------------// C 版基数排序void radix_sort(int *const arr, const int left, const int right) {    const int L = right - left + 1;    // 对数组元素进行一定的校正，例如偏移到以 0 开始的整数区间    const int min_value = regulation(arr, L);    // 初始化 radix 数组，做预处理，后期不必再用 pow 求    init_radix();           // 初始化一些辅助数组    int *_count = (int *)malloc(sizeof(int) * (radix + 1));    int *pos = (int *)malloc(sizeof(int) * L);    int *sub = (int *)malloc(sizeof(int) * L);    int i, t;    // 总共要进行 max_radix_len 次收集，最多次 max_radix_len 次    const int max_len = get_max_len(arr, L);    for (t = 0;t &lt; max_len; ++t) {        memset(_count, 0, sizeof(int) * (radix + 1));        for (i = 0;i &lt; L; ++i) {            sub[i] = arr[i];            pos[i] = get_bucket_pos(sub[i], t); // 放在哪个桶            ++_count[pos[i] + 1];  // 这个桶的下一个桶的位置后挪一位, 在后面体现        }        for (i = 1;i &lt;= radix; ++i) // 计算每一个桶的开始位置            _count[i] += _count[i - 1];        for (i = 0;i &lt; L; ++i) {            const int index = _count[pos[i]]++; // 这个放在 pos[i] 的数字, 该放在哪里            arr[index] = sub[i];        }    }    // 这样的写法....可惜不能用 RAII; 日后用内存池替换    free(sub);    free(pos);    free(_count);    // 将数组元素偏移回来    for (i = 0;i &lt; L; ++i) arr[i] += min_value;}// 将数组偏移到以 0 开始，其他数据类型可以另外设计，例如 float 乘以某个大值，字符串哈希成某个值等等int regulation(int *const arr, const int L) {    int min_value = INT_MAX, i;    for (i = 0;i &lt; L; ++i)        if(arr[i] &lt; min_value)            min_value = arr[i];    for (i = 0;i &lt; L; ++i)        arr[i] -= min_value;    return min_value;}// 预处理小 trick，空间换时间void init_radix() {    radix_size = ceil(log(INT_MAX) / log(radix));    for (int i = 0;i &lt; radix_size; ++i)         radix_arr[i] = 1.0 / pow(radix, i);}// 获取 value 第 t 位的值// inlineint get_bucket_pos(const int value, const int t) {    const int v = value * radix_arr[t];    return v % radix;}// 获取最多需要收集多少次，基数 = 10 时就是最大值有多少位int get_max_len(const int *const arr, const int L) {    int max_value = arr[0], i;    for (i = 1;i &lt; L; ++i)        if(arr[i] &gt; max_value)            max_value = arr[i];    return ceil(log(max_value) / log(radix));}// ---------------------------- 希尔排序 ------------------------------------void shell_sort(int *arr, const int left, const int right) {    // 开始排序    int i, j, L = right - left + 1;    for(i = intervals_len - 1;i &gt;= 0 ; --i) {        // 直接遍历，轮到谁，就直接对它所在的当前小份进行插入排序        for(j = intervals[i];j &lt; L; ++j) {            tmp = arr[j];            while(j &gt;= intervals[i] &amp;&amp; arr[j - intervals[i]] &gt; tmp) {                arr[j] = arr[j - intervals[i]];                j -= intervals[i];            }            arr[j] = tmp;        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划（dp）-最短编辑距离</title>
    <link href="/2019/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <url>/2019/11/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>应该是我接触的第一个动态规划的算法，可以说是很经典了，Levenstein 距离。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote><p>设A和B是2个字符串。要用最少的字符操作将字符串A转换为字符串B。这里所说的字符操作包括:<br>(1)删除一个字符;<br>(2)插入一个字符；<br>(3)将一个字符改为另一个字符。<br>将字符串 A 变换为字符串 B 所用的最少字符操作数，称为字符串 A 到 B 的编辑距离,记为d(A,B)。试设计一个有效算法,对任给的2个字符串 A 和 B,计算出它们的编辑距离d(A,B)</p></blockquote><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><blockquote><p>输入数据的第一行是一个正整数，表示一共有几组数据。</p><ul><li>每组数据有两行，每行一个字符串。</li><li>每个字符串长度不超过1000</li><li>字符串中只含小写英文字母</li></ul></blockquote><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><blockquote><p>对于每组数据，请输出一个整数表示两个字符串的编辑距离(最短编辑距离)</p></blockquote><blockquote><p><strong><em>Sample Input</em></strong> :<br>10 AGTCTGACGC<br>11 AGTAAGTAGGC<br>5 abcdy<br>4 abds<br>7 dewjfsr<br>4 ejfr<br><strong><em>Sample output</em></strong><br>4<br>2<br>3</p></blockquote><h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><p><img src="/images/algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84-dp-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/11-11-52.jpg" srcset="/img/loading.gif" alt><br>假设求 ‘abcy’ 和 ‘aby’ 的编辑距离</p><blockquote><p>$dp[i - 1][j] + 1$，</p><p>删除’abcy’中的y —— 也可以理解为在求 ‘abc’ 和 ‘aby’ 编辑距离的基础上，在 ‘abc’ 尾部插入一个 y，推导而来</p><p>$dp[i][j - 1] + 1$</p><p>删除 ‘aby’ 中的 y, —— 也可以理解为在求 ‘abcy’ 和 ‘ab’编辑距离的基础上，在 ’ab’ 尾部插入一个 y，推导而来</p><p>$ dp[i - 1][j - 1] \qquad{ A[i - 1] = B[j - 1]} $</p><p> 因为 ‘abcy’ 第 i 个字符 ‘y’ 和 ‘aby’ 中当前第 j 个字符  ‘y’ 相等，所以，可以认为在求 ‘abc’ 和 ‘ab’ 编辑距离的基础上没有任何编辑操作，后接一个空字符。</p><p>$ dp[i - 1][j - 1] + 1 \qquad{ A[i - 1] \neq B[j - 1]} $</p></blockquote><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>求最短编辑距离 <a href="http://poj.org/problem?id=3356" target="_blank" rel="noopener">POJ 3356</a></p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define Min(a , b , c) (a &lt; b ? (a &lt; c ? a : c) : (b &lt; c ? b : c))int dp[1010][1010];char s1[1010] , s2[1010];int main(){    // freopen(&quot;Levenshtein.in&quot;, &quot;r&quot;, stdin);    int n , m , i , j , cost;    while(~scanf(&quot;%d%s%d%s&quot; , &amp;n, s1 , &amp;m, s2)){        memset(dp, 0, sizeof(dp));        for(i = 0; i &lt;= n; ++i) dp[i][0] = i;  // 另一个字符串长度为 0 时，长度就是本字符串当前长度        for(i = 0; i &lt;= m; ++i) dp[0][i] = i;        for(i = 1; i &lt;= n; ++i)            for(j = 1; j &lt;= m; ++j){                // 若当前字符相等，dp[i][j] = dp[i - 1][j - 1]；否则，替换当前字符，编辑次数 +1                cost = s1[i - 1] == s2[j - 1] ? 0 : 1;                    dp[i][j] = Min(dp[i-1][j] + 1 , dp[i][j - 1] + 1 , dp[i - 1][j - 1] + cost);            }            printf(&quot;%d\n&quot;, dp[n][m]);    }    return 0;}</code></pre><p>分析：</p><blockquote><ol><li>dp[i][j] 代表的是句子 s1 到了第 i 个字符，s2 到了第 j 个字符的编辑距离，例如：<br>s1 = ‘abcy’<br>s2 = ‘aby’<br>dp[3][2] 代表 s1的子句 ‘abc’，和 s2 的子句 ‘ab’ 的(最短)编辑距离，是 1<br>根据循环特性，可得 0 &lt;= i &lt; 3，0 &lt;= j &lt; 2，dp[i][j] 都推导出来了。</li><li><code>for(i = 0; i &lt;= n; ++i) dp[i][0] = i;</code><br>初始化推导的首项(类似数组的推导，一般都具有首项)，当两个句子中有一个句子为空，最短编辑距离就是非空的句子长度，在这里，i 代表的是<code>当前</code>的非空句子长度。</li><li><code>cost = s1[i - 1] == s2[j - 1] ? 0 : 1;</code><br>因为字符串从下标0开始存储，所以 s1[i - 1] 代表句子 s1 当前的字符，s2[j - 1] 同理。<br>(1). 如果 s1 和 s2 当前的字符相等，那么 <code>dp[i][j] 有可能是 dp[i - 1[j - 1]</code>，例子：<br>求 ‘abcy’ 和 ‘aby’ 的编辑距离，已知 ‘abc’ 和 ‘ab’ 的编辑距离是 1，恰好最后一个字符 ‘y’ 相等，那么 ‘abcy’ 和 ‘aby’ 的编辑距离可能依旧是 1.<br>(2). 如果 s1 和 s2 当前的字符不相等，说明，在已知 dp[i - 1][j - 1] 的基础，至少还要再编辑一次(替换)，编辑次数 + 1</li><li><code>dp[i][j] = Min(dp[i-1][j] + 1 , dp[i][j - 1] + 1 , dp[i - 1][j - 1] + cost);</code><br>dp[i][j] 可以有三种可能性，从中选最小的距离作为当前的最短编辑距离。</li></ol></blockquote><h1 id="优化-or-变体"><a href="#优化-or-变体" class="headerlink" title="优化 or 变体"></a>优化 or 变体</h1><h2 id="1-滚动数组，降低空间复杂度"><a href="#1-滚动数组，降低空间复杂度" class="headerlink" title="1. 滚动数组，降低空间复杂度"></a>1. 滚动数组，降低空间复杂度</h2><p>观察主循环</p><pre><code class="cpp">for(i = 1; i &lt;= n; ++i)    for(j = 1; j &lt;= m; ++j){         cost = s1[i - 1] == s2[j - 1] ? 0 : 1;            dp[i][j] = Min(dp[i-1][j] + 1 , dp[i][j-1] + 1 , dp[i-1][j-1] + cost);    }</code></pre><p>外循环是 i，i 代表逐行；可以发现，每次推导 dp[i][j] ，都只利用了 dp[i - 1] 的信息，也就是说，推导第 i 层，只需要记录第 i - 1层的状态，所以也只需要存储第 i - 1 层的信息。<br>原来的 dp[1005][1005] 存储的是所有层的状态，现在减少到相邻两层 dp[2][1005]，也就是 dp[0][1005] 和 dp[1][1005]，假设偶数层都存储在 dp[0][1005]，奇数层都存储在 dp[1][1005]。<br>通过判断奇偶数  <code>%2</code>，但位运算 <code>&amp;1</code> 可以略微加速，实现类似“滚动”的效果。<br>故修改代码如下：</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define Min(a , b , c) (a &lt; b ? (a &lt; c ? a : c) : (b &lt; c ? b : c))int dp[2][1010];char s1[1010] , s2[1010];int main(){    // freopen(&quot;Levenshtein.in&quot;, &quot;r&quot;, stdin);    int n , m , i , j , cost;    while(~scanf(&quot;%d%s%d%s&quot; , &amp;n, s1 , &amp;m, s2)){        memset(dp, 0, sizeof(dp));        for(i = 0; i &lt;= m; ++i)             dp[0][i] = i;        for(i = 1; i &lt;= n; ++i) {            dp[i &amp; 1][0] = i;    // 因为 dp 只能记录相邻两层的状态，所以不能像原来一样初始化            for(j = 1; j &lt;= m; ++j){                // 若当前字符相等，dp[i][j] = dp[i - 1][j - 1]；否则，替换当前字符，编辑次数 +1                cost = s1[i - 1] == s2[j - 1] ? 0 : 1;                     dp[i &amp; 1][j] = Min(dp[(i-1) &amp; 1][j] + 1 , dp[i &amp; 1][j-1] + 1 , dp[(i-1) &amp; 1][j-1] + cost);            }           }        printf(&quot;%d\n&quot;, dp[n &amp; 1][m]);    }    return 0;}</code></pre><p>前后对比：<br><img src="/images/algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84-dp-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/11-14-01.jpg" srcset="/img/loading.gif" alt><br><img src="/images/algorithms/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84-dp-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/11-14-23.jpg" srcset="/img/loading.gif" alt></p><p>可以看出，时间消耗一样，但内存消耗缩小到原来的十几分之一。滚动数组对于这种情况能节省极大内存。同时，也能看出位运算 &amp; 对于程序速度的影响其实很细微。<br>但滚动数组也存在缺点，因为只记录了相邻两层的状态，所以不能找回推导的路径( A如何编辑得到  B )。</p><h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><p>根据推导方程，递归的回溯过程是正向的推导。代码如下：</p><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define Min(a, b, c) (a &lt; b ? (a &lt; c ? a : c) : (b &lt; c ? b : c))int dp[1010][1010];char s1[1010], s2[1010];int edit_distance(const int i, const int j) {    // 判断边界条件    if(i == 0) return j;    if(j == 0) return i;    // 判断当前两个句子的字符是否一样，是否需要额外的编辑操作    const int cost = s1[i - 1] == s2[j - 1] ? 0 : 1;    const int a = edit_distance(i - 1, j) + 1;    const int b = edit_distance(i, j - 1) + 1;    const int c = edit_distance(i - 1, j - 1) + cost;    return Min(a, b, c);}int main(){    // freopen(&quot;Levenshtein.in&quot;, &quot;r&quot;, stdin);    int n, m;    while(~scanf(&quot;%d%s%d%s&quot;, &amp;n, s1, &amp;m, s2))        printf(&quot;%d\n&quot;, edit_distance(n, m));    return 0;}</code></pre><p>但是根据题目要求，字符串长度可达 1000，这对于递归来说深度太大，压栈参数多，在 OJ 上会超时，但是递归过程很明晰。<br>注：又掉进了一个坑！</p><pre><code class="cpp">return Min(    edit_distance(i - 1, j) + 1,    edit_distance(i, j - 1) + 1,    edit_distance(i - 1, j - 1) + cost);</code></pre><blockquote><p>define 宏定义和递归不可以一起用，宏定义是展开，会计算多次递归，浪费时间与空间！</p></blockquote><h1 id="内容扩展"><a href="#内容扩展" class="headerlink" title="内容扩展"></a>内容扩展</h1><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><p>可以用于模糊搜索、找相似度较高的句子，应用有拼写检查、求相似度等。<br>    例如给定两个句子：</p><blockquote><p>A = “最佳的编辑软件” 和<br>B = “最佳的游戏软件”，</p></blockquote><p>二者的最短编辑距离是 2 (2次替换)，那么二者的相似度可以用 1 - 编辑距离/ [len(A) + len(B)]表示，这里是 </p><blockquote><p>1 - 2 / (7 + 7) = 1 - 0.1428 = 0.8571，</p></blockquote><p>编辑距离越短，表示这两个句子经过越少次数的插入或替换等操作即可相互转换，相似度越高</p><h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>字符串编辑距离只考虑到了句子在“字形”上的距离，并没有考虑到每个字符(短语)背后代表的深层含义，在上个例子中：</p><blockquote><p>“编辑”和“游戏”编辑距离是2，但二者在语义上的差距较大；<br>    考虑“休闲”和“游戏”，字形上的编辑距离也是2，但是二者在语义上无疑更近一步。</p></blockquote><p>对于搜索等任务来说，用户更渴望得到在语义上更相近的答案。<br>    这也是传统文本搜索的弊病，没考虑语义距离；</p><h2 id="3-更好的距离衡量"><a href="#3-更好的距离衡量" class="headerlink" title="3. 更好的距离衡量"></a>3. 更好的距离衡量</h2><p>那么如何衡量词语之间的语义距离呢？词向量给出了答案 ：<a href="https://www.cnblogs.com/pinard/p/7160330.html" target="_blank" rel="noopener">word2vec</a>。</p><p> 基本原理可以直观理解为：</p><ol><li>利用向量代表一个词语，将词语映射到“语义空间”，两个词语之间的距离可以通过它们的向量距离来衡量。</li><li>如果表达【游戏】对 【编辑】与【休闲】的不同距离呢？共现频率的统计，经常出现在一起的词语在语义空间上应该是相近的，例如“游戏”和“休闲”经常出现[在一起开黑、网吧]等相关的上下文中，那么“游戏”和“休闲”在语义空间上就是相似的。但“编辑”和“游戏”几乎不会出现在相似的上下文中，二者的语义距离就很大了。通过梯度下降等算法不断拟合以上的情况，使得【游戏】与【休闲】的向量距离更小，但【游戏】与【编辑】之间的向量距离更大。</li></ol><h2 id="类似的算法"><a href="#类似的算法" class="headerlink" title="类似的算法"></a>类似的算法</h2><p><a href>最大上升子序列</a><br><a href>最大公共子序列</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
